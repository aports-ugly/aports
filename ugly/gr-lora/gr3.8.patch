diff -Nur src/gr-lora-0.6.2/CMakeLists.txt gr-lora-0.6.2/CMakeLists.txt
--- src/gr-lora-0.6.2/CMakeLists.txt	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/CMakeLists.txt	2019-08-14 23:55:10.420000000 +0000
@@ -31,7 +31,7 @@
 ########################################################################
 # Project setup
 ########################################################################
-cmake_minimum_required(VERSION 2.6)
+cmake_minimum_required(VERSION 3.8)
 project(gr-lora CXX C)
 enable_testing()
 
@@ -45,10 +45,14 @@
 #make sure our local CMake Modules path comes first
 list(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake/Modules)
 
+cmake_policy(SET CMP0011 NEW)
+
 ########################################################################
 # Compiler specific setup
 ########################################################################
-if(CMAKE_COMPILER_IS_GNUCXX AND NOT WIN32)
+if((CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR
+       CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+       AND NOT WIN32)
     #http://gcc.gnu.org/wiki/Visibility
     add_definitions(-fvisibility=hidden)
     add_definitions(-std=c++11)
@@ -56,31 +60,34 @@
     add_definitions(-Wextra)
 endif()
 
-########################################################################
-# Find boost
-########################################################################
-if(UNIX AND EXISTS "/usr/lib64")
-    list(APPEND BOOST_LIBRARYDIR "/usr/lib64") #fedora 64-bit fix
-endif(UNIX AND EXISTS "/usr/lib64")
-set(Boost_ADDITIONAL_VERSIONS
-    "1.35.0" "1.35" "1.36.0" "1.36" "1.37.0" "1.37" "1.38.0" "1.38" "1.39.0" "1.39"
-    "1.40.0" "1.40" "1.41.0" "1.41" "1.42.0" "1.42" "1.43.0" "1.43" "1.44.0" "1.44"
-    "1.45.0" "1.45" "1.46.0" "1.46" "1.47.0" "1.47" "1.48.0" "1.48" "1.49.0" "1.49"
-    "1.50.0" "1.50" "1.51.0" "1.51" "1.52.0" "1.52" "1.53.0" "1.53" "1.54.0" "1.54"
-    "1.55.0" "1.55" "1.56.0" "1.56" "1.57.0" "1.57" "1.58.0" "1.58" "1.59.0" "1.59"
-    "1.60.0" "1.60" "1.61.0" "1.61" "1.62.0" "1.62" "1.63.0" "1.63" "1.64.0" "1.64"
-    "1.65.0" "1.65" "1.66.0" "1.66" "1.67.0" "1.67" "1.68.0" "1.68" "1.69.0" "1.69"
-)
-find_package(Boost "1.35" COMPONENTS filesystem system)
-
-if(NOT Boost_FOUND)
-    message(FATAL_ERROR "Boost required to compile lora")
-endif()
+IF(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+    SET(CMAKE_CXX_STANDARD 11)
+ELSEIF(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+    SET(CMAKE_CXX_STANDARD 11)
+ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
+    SET(CMAKE_CXX_STANDARD 11)
+ELSE()
+    message(WARNING "C++ standard could not be set because compiler is not GNU, Clang or MSVC.")
+ENDIF()
+
+IF(CMAKE_C_COMPILER_ID STREQUAL "GNU")
+    SET(CMAKE_C_STANDARD 11)
+ELSEIF(CMAKE_C_COMPILER_ID MATCHES "Clang")
+    SET(CMAKE_C_STANDARD 11)
+ELSEIF(CMAKE_C_COMPILER_ID STREQUAL "MSVC")
+    SET(CMAKE_C_STANDARD 11)
+ELSE()
+    message(WARNING "C standard could not be set because compiler is not GNU, Clang or MSVC.")
+ENDIF()
 
 ########################################################################
 # Install directories
 ########################################################################
+find_package(Gnuradio "3.8" REQUIRED COMPONENTS blocks filter fft)
+include(GrVersion)
+
 include(GrPlatform) #define LIB_SUFFIX
+
 set(GR_RUNTIME_DIR      bin)
 set(GR_LIBRARY_DIR      lib${LIB_SUFFIX})
 set(GR_INCLUDE_DIR      include/lora)
@@ -120,13 +127,6 @@
 find_package(CppUnit)
 find_package(Doxygen)
 
-# Search for GNU Radio and its components and versions. Add any
-# components required to the list of GR_REQUIRED_COMPONENTS (in all
-# caps such as FILTER or FFT) and change the version to the minimum
-# API compatible version required.
-set(GR_REQUIRED_COMPONENTS RUNTIME FILTER)
-find_package(Gnuradio "3.7.2" REQUIRED)
-
 if(NOT CPPUNIT_FOUND)
     message(FATAL_ERROR "CppUnit required to compile lora")
 endif()
@@ -141,29 +141,6 @@
 endif(DOXYGEN_FOUND)
 
 ########################################################################
-# Setup the include and linker paths
-########################################################################
-include_directories(
-    ${CMAKE_SOURCE_DIR}/lib
-    ${CMAKE_SOURCE_DIR}/include
-    ${CMAKE_BINARY_DIR}/lib
-    ${CMAKE_BINARY_DIR}/include
-    ${Boost_INCLUDE_DIRS}
-    ${CPPUNIT_INCLUDE_DIRS}
-    ${GNURADIO_ALL_INCLUDE_DIRS}
-)
-
-link_directories(
-    ${Boost_LIBRARY_DIRS}
-    ${CPPUNIT_LIBRARY_DIRS}
-    ${GNURADIO_RUNTIME_LIBRARY_DIRS}
-)
-
-# Set component parameters
-set(GR_LORA_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/include CACHE INTERNAL "" FORCE)
-set(GR_LORA_SWIG_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/swig CACHE INTERNAL "" FORCE)
-
-########################################################################
 # Create uninstall target
 ########################################################################
 configure_file(
diff -Nur src/gr-lora-0.6.2/cmake/Modules/FindGnuradioRuntime.cmake gr-lora-0.6.2/cmake/Modules/FindGnuradioRuntime.cmake
--- src/gr-lora-0.6.2/cmake/Modules/FindGnuradioRuntime.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/FindGnuradioRuntime.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,36 +0,0 @@
-INCLUDE(FindPkgConfig)
-PKG_CHECK_MODULES(PC_GNURADIO_RUNTIME gnuradio-runtime)
-
-if(PC_GNURADIO_RUNTIME_FOUND)
-  # look for include files
-  FIND_PATH(
-    GNURADIO_RUNTIME_INCLUDE_DIRS
-    NAMES gnuradio/top_block.h
-    HINTS $ENV{GNURADIO_RUNTIME_DIR}/include
-          ${PC_GNURADIO_RUNTIME_INCLUDE_DIRS}
-          ${CMAKE_INSTALL_PREFIX}/include
-    PATHS /usr/local/include
-          /usr/include
-    )
-
-  # look for libs
-  FIND_LIBRARY(
-    GNURADIO_RUNTIME_LIBRARIES
-    NAMES gnuradio-runtime
-    HINTS $ENV{GNURADIO_RUNTIME_DIR}/lib
-          ${PC_GNURADIO_RUNTIME_LIBDIR}
-          ${CMAKE_INSTALL_PREFIX}/lib/
-          ${CMAKE_INSTALL_PREFIX}/lib64/
-    PATHS /usr/local/lib
-          /usr/local/lib64
-          /usr/lib
-          /usr/lib64
-    )
-
-  set(GNURADIO_RUNTIME_FOUND ${PC_GNURADIO_RUNTIME_FOUND})
-endif(PC_GNURADIO_RUNTIME_FOUND)
-
-INCLUDE(FindPackageHandleStandardArgs)
-# do not check GNURADIO_RUNTIME_INCLUDE_DIRS, is not set when default include path us used.
-FIND_PACKAGE_HANDLE_STANDARD_ARGS(GNURADIO_RUNTIME DEFAULT_MSG GNURADIO_RUNTIME_LIBRARIES)
-MARK_AS_ADVANCED(GNURADIO_RUNTIME_LIBRARIES GNURADIO_RUNTIME_INCLUDE_DIRS)
diff -Nur src/gr-lora-0.6.2/cmake/Modules/GrMiscUtils.cmake gr-lora-0.6.2/cmake/Modules/GrMiscUtils.cmake
--- src/gr-lora-0.6.2/cmake/Modules/GrMiscUtils.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/GrMiscUtils.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,525 +0,0 @@
-# Copyright 2010-2011,2014 Free Software Foundation, Inc.
-#
-# This file is part of GNU Radio
-#
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
-#
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
-
-if(DEFINED __INCLUDED_GR_MISC_UTILS_CMAKE)
-    return()
-endif()
-set(__INCLUDED_GR_MISC_UTILS_CMAKE TRUE)
-
-########################################################################
-# Set global variable macro.
-# Used for subdirectories to export settings.
-# Example: include and library paths.
-########################################################################
-function(GR_SET_GLOBAL var)
-    set(${var} ${ARGN} CACHE INTERNAL "" FORCE)
-endfunction(GR_SET_GLOBAL)
-
-########################################################################
-# Set the pre-processor definition if the condition is true.
-#  - def the pre-processor definition to set and condition name
-########################################################################
-function(GR_ADD_COND_DEF def)
-    if(${def})
-        add_definitions(-D${def})
-    endif(${def})
-endfunction(GR_ADD_COND_DEF)
-
-########################################################################
-# Check for a header and conditionally set a compile define.
-#  - hdr the relative path to the header file
-#  - def the pre-processor definition to set
-########################################################################
-function(GR_CHECK_HDR_N_DEF hdr def)
-    include(CheckIncludeFileCXX)
-    CHECK_INCLUDE_FILE_CXX(${hdr} ${def})
-    GR_ADD_COND_DEF(${def})
-endfunction(GR_CHECK_HDR_N_DEF)
-
-########################################################################
-# Include subdirectory macro.
-# Sets the CMake directory variables,
-# includes the subdirectory CMakeLists.txt,
-# resets the CMake directory variables.
-#
-# This macro includes subdirectories rather than adding them
-# so that the subdirectory can affect variables in the level above.
-# This provides a work-around for the lack of convenience libraries.
-# This way a subdirectory can append to the list of library sources.
-########################################################################
-macro(GR_INCLUDE_SUBDIRECTORY subdir)
-    #insert the current directories on the front of the list
-    list(INSERT _cmake_source_dirs 0 ${CMAKE_CURRENT_SOURCE_DIR})
-    list(INSERT _cmake_binary_dirs 0 ${CMAKE_CURRENT_BINARY_DIR})
-
-    #set the current directories to the names of the subdirs
-    set(CMAKE_CURRENT_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/${subdir})
-    set(CMAKE_CURRENT_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${subdir})
-
-    #include the subdirectory CMakeLists to run it
-    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
-    include(${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt)
-
-    #reset the value of the current directories
-    list(GET _cmake_source_dirs 0 CMAKE_CURRENT_SOURCE_DIR)
-    list(GET _cmake_binary_dirs 0 CMAKE_CURRENT_BINARY_DIR)
-
-    #pop the subdir names of the front of the list
-    list(REMOVE_AT _cmake_source_dirs 0)
-    list(REMOVE_AT _cmake_binary_dirs 0)
-endmacro(GR_INCLUDE_SUBDIRECTORY)
-
-########################################################################
-# Check if a compiler flag works and conditionally set a compile define.
-#  - flag the compiler flag to check for
-#  - have the variable to set with result
-########################################################################
-macro(GR_ADD_CXX_COMPILER_FLAG_IF_AVAILABLE flag have)
-    include(CheckCXXCompilerFlag)
-    CHECK_CXX_COMPILER_FLAG(${flag} ${have})
-    if(${have})
-      if(${CMAKE_VERSION} VERSION_GREATER "2.8.4")
-        STRING(FIND "${CMAKE_CXX_FLAGS}" "${flag}" flag_dup)
-        if(${flag_dup} EQUAL -1)
-          set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${flag}")
-          set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${flag}")
-        endif(${flag_dup} EQUAL -1)
-      endif(${CMAKE_VERSION} VERSION_GREATER "2.8.4")
-    endif(${have})
-endmacro(GR_ADD_CXX_COMPILER_FLAG_IF_AVAILABLE)
-
-########################################################################
-# Generates the .la libtool file
-# This appears to generate libtool files that cannot be used by auto*.
-# Usage GR_LIBTOOL(TARGET [target] DESTINATION [dest])
-# Notice: there is not COMPONENT option, these will not get distributed.
-########################################################################
-function(GR_LIBTOOL)
-    if(NOT DEFINED GENERATE_LIBTOOL)
-        set(GENERATE_LIBTOOL OFF) #disabled by default
-    endif()
-
-    if(GENERATE_LIBTOOL)
-        include(CMakeParseArgumentsCopy)
-        CMAKE_PARSE_ARGUMENTS(GR_LIBTOOL "" "TARGET;DESTINATION" "" ${ARGN})
-
-        find_program(LIBTOOL libtool)
-        if(LIBTOOL)
-            include(CMakeMacroLibtoolFile)
-            CREATE_LIBTOOL_FILE(${GR_LIBTOOL_TARGET} /${GR_LIBTOOL_DESTINATION})
-        endif(LIBTOOL)
-    endif(GENERATE_LIBTOOL)
-
-endfunction(GR_LIBTOOL)
-
-########################################################################
-# Do standard things to the library target
-# - set target properties
-# - make install rules
-# Also handle gnuradio custom naming conventions w/ extras mode.
-########################################################################
-function(GR_LIBRARY_FOO target)
-    #parse the arguments for component names
-    include(CMakeParseArgumentsCopy)
-    CMAKE_PARSE_ARGUMENTS(GR_LIBRARY "" "RUNTIME_COMPONENT;DEVEL_COMPONENT" "" ${ARGN})
-
-    #set additional target properties
-    set_target_properties(${target} PROPERTIES SOVERSION ${LIBVER})
-
-    #install the generated files like so...
-    install(TARGETS ${target}
-        LIBRARY DESTINATION ${GR_LIBRARY_DIR} COMPONENT ${GR_LIBRARY_RUNTIME_COMPONENT} # .so/.dylib file
-        ARCHIVE DESTINATION ${GR_LIBRARY_DIR} COMPONENT ${GR_LIBRARY_DEVEL_COMPONENT}   # .lib file
-        RUNTIME DESTINATION ${GR_RUNTIME_DIR} COMPONENT ${GR_LIBRARY_RUNTIME_COMPONENT} # .dll file
-    )
-
-    #extras mode enabled automatically on linux
-    if(NOT DEFINED LIBRARY_EXTRAS)
-        set(LIBRARY_EXTRAS ${LINUX})
-    endif()
-
-    #special extras mode to enable alternative naming conventions
-    if(LIBRARY_EXTRAS)
-
-        #create .la file before changing props
-        GR_LIBTOOL(TARGET ${target} DESTINATION ${GR_LIBRARY_DIR})
-
-        #give the library a special name with ultra-zero soversion
-        set_target_properties(${target} PROPERTIES OUTPUT_NAME ${target}-${LIBVER} SOVERSION "0.0.0")
-        set(target_name lib${target}-${LIBVER}.so.0.0.0)
-
-        #custom command to generate symlinks
-        add_custom_command(
-            TARGET ${target}
-            POST_BUILD
-            COMMAND ${CMAKE_COMMAND} -E create_symlink ${target_name} ${CMAKE_CURRENT_BINARY_DIR}/lib${target}.so
-            COMMAND ${CMAKE_COMMAND} -E create_symlink ${target_name} ${CMAKE_CURRENT_BINARY_DIR}/lib${target}-${LIBVER}.so.0
-            COMMAND ${CMAKE_COMMAND} -E touch ${target_name} #so the symlinks point to something valid so cmake 2.6 will install
-        )
-
-        #and install the extra symlinks
-        install(
-            FILES
-            ${CMAKE_CURRENT_BINARY_DIR}/lib${target}.so
-            ${CMAKE_CURRENT_BINARY_DIR}/lib${target}-${LIBVER}.so.0
-            DESTINATION ${GR_LIBRARY_DIR} COMPONENT ${GR_LIBRARY_RUNTIME_COMPONENT}
-        )
-
-    endif(LIBRARY_EXTRAS)
-endfunction(GR_LIBRARY_FOO)
-
-########################################################################
-# Create a dummy custom command that depends on other targets.
-# Usage:
-#   GR_GEN_TARGET_DEPS(unique_name target_deps <target1> <target2> ...)
-#   ADD_CUSTOM_COMMAND(<the usual args> ${target_deps})
-#
-# Custom command cant depend on targets, but can depend on executables,
-# and executables can depend on targets. So this is the process:
-########################################################################
-function(GR_GEN_TARGET_DEPS name var)
-    file(
-        WRITE ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp.in
-        "int main(void){return 0;}\n"
-    )
-    execute_process(
-        COMMAND ${CMAKE_COMMAND} -E copy_if_different
-        ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp.in
-        ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp
-    )
-    add_executable(${name} ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp)
-    if(ARGN)
-        add_dependencies(${name} ${ARGN})
-    endif(ARGN)
-
-    if(CMAKE_CROSSCOMPILING)
-        set(${var} "DEPENDS;${name}" PARENT_SCOPE) #cant call command when cross
-    else()
-        set(${var} "DEPENDS;${name};COMMAND;${name}" PARENT_SCOPE)
-    endif()
-endfunction(GR_GEN_TARGET_DEPS)
-
-########################################################################
-# Control use of gr_logger
-# Usage:
-#   GR_LOGGING()
-#
-# Will set ENABLE_GR_LOG to 1 by default.
-# Can manually set with -DENABLE_GR_LOG=0|1
-########################################################################
-function(GR_LOGGING)
-  find_package(Log4cpp)
-
-  OPTION(ENABLE_GR_LOG "Use gr_logger" ON)
-  if(ENABLE_GR_LOG)
-    # If gr_logger is enabled, make it usable
-    add_definitions( -DENABLE_GR_LOG )
-
-    # also test LOG4CPP; if we have it, use this version of the logger
-    # otherwise, default to the stdout/stderr model.
-    if(LOG4CPP_FOUND)
-      SET(HAVE_LOG4CPP True CACHE INTERNAL "" FORCE)
-      add_definitions( -DHAVE_LOG4CPP )
-    else(not LOG4CPP_FOUND)
-      SET(HAVE_LOG4CPP False CACHE INTERNAL "" FORCE)
-      SET(LOG4CPP_INCLUDE_DIRS "" CACHE INTERNAL "" FORCE)
-      SET(LOG4CPP_LIBRARY_DIRS "" CACHE INTERNAL "" FORCE)
-      SET(LOG4CPP_LIBRARIES "" CACHE INTERNAL "" FORCE)
-    endif(LOG4CPP_FOUND)
-
-    SET(ENABLE_GR_LOG ${ENABLE_GR_LOG} CACHE INTERNAL "" FORCE)
-
-  else(ENABLE_GR_LOG)
-    SET(HAVE_LOG4CPP False CACHE INTERNAL "" FORCE)
-    SET(LOG4CPP_INCLUDE_DIRS "" CACHE INTERNAL "" FORCE)
-    SET(LOG4CPP_LIBRARY_DIRS "" CACHE INTERNAL "" FORCE)
-    SET(LOG4CPP_LIBRARIES "" CACHE INTERNAL "" FORCE)
-  endif(ENABLE_GR_LOG)
-
-  message(STATUS "ENABLE_GR_LOG set to ${ENABLE_GR_LOG}.")
-  message(STATUS "HAVE_LOG4CPP set to ${HAVE_LOG4CPP}.")
-  message(STATUS "LOG4CPP_LIBRARIES set to ${LOG4CPP_LIBRARIES}.")
-
-endfunction(GR_LOGGING)
-
-########################################################################
-# Run GRCC to compile .grc files into .py files.
-#
-# Usage: GRCC(filename, directory)
-#    - filenames: List of file name of .grc file
-#    - directory: directory of built .py file - usually in
-#                 ${CMAKE_CURRENT_BINARY_DIR}
-#    - Sets PYFILES: output converted GRC file names to Python files.
-########################################################################
-function(GRCC)
-  # Extract directory from list of args, remove it for the list of filenames.
-  list(GET ARGV -1 directory)
-  list(REMOVE_AT ARGV -1)
-  set(filenames ${ARGV})
-  file(MAKE_DIRECTORY ${directory})
-
-  SET(GRCC_COMMAND ${CMAKE_SOURCE_DIR}/gr-utils/python/grcc)
-
-  # GRCC uses some stuff in grc and gnuradio-runtime, so we force
-  # the known paths here
-  list(APPEND PYTHONPATHS
-    ${CMAKE_SOURCE_DIR}
-    ${CMAKE_SOURCE_DIR}/gnuradio-runtime/python
-    ${CMAKE_SOURCE_DIR}/gnuradio-runtime/lib/swig
-    ${CMAKE_BINARY_DIR}/gnuradio-runtime/lib/swig
-    )
-
-  if(WIN32)
-    #SWIG generates the python library files into a subdirectory.
-    #Therefore, we must append this subdirectory into PYTHONPATH.
-    #Only do this for the python directories matching the following:
-    foreach(pydir ${PYTHONPATHS})
-      get_filename_component(name ${pydir} NAME)
-      if(name MATCHES "^(swig|lib|src)$")
-        list(APPEND PYTHONPATHS ${pydir}/${CMAKE_BUILD_TYPE})
-      endif()
-    endforeach(pydir)
-  endif(WIN32)
-
-  file(TO_NATIVE_PATH "${PYTHONPATHS}" pypath)
-
-  if(UNIX)
-    list(APPEND pypath "$PYTHONPATH")
-    string(REPLACE ";" ":" pypath "${pypath}")
-    set(ENV{PYTHONPATH} ${pypath})
-  endif(UNIX)
-
-  if(WIN32)
-    list(APPEND pypath "%PYTHONPATH%")
-    string(REPLACE ";" "\\;" pypath "${pypath}")
-    #list(APPEND environs "PYTHONPATH=${pypath}")
-    set(ENV{PYTHONPATH} ${pypath})
-  endif(WIN32)
-
-  foreach(f ${filenames})
-    execute_process(
-      COMMAND ${GRCC_COMMAND} -d ${directory} ${f}
-      )
-    string(REPLACE ".grc" ".py" pyfile "${f}")
-    string(REPLACE "${CMAKE_CURRENT_SOURCE_DIR}" "${CMAKE_CURRENT_BINARY_DIR}" pyfile "${pyfile}")
-    list(APPEND pyfiles ${pyfile})
-  endforeach(f)
-
-  set(PYFILES ${pyfiles} PARENT_SCOPE)
-endfunction(GRCC)
-
-########################################################################
-# Check if HAVE_PTHREAD_SETSCHEDPARAM and HAVE_SCHED_SETSCHEDULER
-#  should be defined
-########################################################################
-macro(GR_CHECK_LINUX_SCHED_AVAIL)
-set(CMAKE_REQUIRED_LIBRARIES -lpthread)
-    CHECK_CXX_SOURCE_COMPILES("
-        #include <pthread.h>
-        int main(){
-            pthread_t pthread;
-            pthread_setschedparam(pthread,  0, 0);
-            return 0;
-        } " HAVE_PTHREAD_SETSCHEDPARAM
-    )
-    GR_ADD_COND_DEF(HAVE_PTHREAD_SETSCHEDPARAM)
-
-    CHECK_CXX_SOURCE_COMPILES("
-        #include <sched.h>
-        int main(){
-            pid_t pid;
-            sched_setscheduler(pid, 0, 0);
-            return 0;
-        } " HAVE_SCHED_SETSCHEDULER
-    )
-    GR_ADD_COND_DEF(HAVE_SCHED_SETSCHEDULER)
-endmacro(GR_CHECK_LINUX_SCHED_AVAIL)
-
-########################################################################
-# Macros to generate source and header files from template
-########################################################################
-macro(GR_EXPAND_X_H component root)
-
-  include(GrPython)
-
-  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-"#!${PYTHON_EXECUTABLE}
-
-import sys, os, re
-sys.path.append('${GR_RUNTIME_PYTHONPATH}')
-os.environ['srcdir'] = '${CMAKE_CURRENT_SOURCE_DIR}'
-os.chdir('${CMAKE_CURRENT_BINARY_DIR}')
-
-if __name__ == '__main__':
-    import build_utils
-    root, inp = sys.argv[1:3]
-    for sig in sys.argv[3:]:
-        name = re.sub ('X+', sig, root)
-        d = build_utils.standard_dict2(name, sig, '${component}')
-        build_utils.expand_template(d, inp)
-")
-
-  #make a list of all the generated headers
-  unset(expanded_files_h)
-  foreach(sig ${ARGN})
-    string(REGEX REPLACE "X+" ${sig} name ${root})
-    list(APPEND expanded_files_h ${CMAKE_CURRENT_BINARY_DIR}/${name}.h)
-  endforeach(sig)
-  unset(name)
-
-  #create a command to generate the headers
-  add_custom_command(
-    OUTPUT ${expanded_files_h}
-    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}.h.t
-    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
-    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-    ${root} ${root}.h.t ${ARGN}
-  )
-
-  #install rules for the generated headers
-  list(APPEND generated_includes ${expanded_files_h})
-
-endmacro(GR_EXPAND_X_H)
-
-macro(GR_EXPAND_X_CC_H component root)
-
-  include(GrPython)
-
-  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-"#!${PYTHON_EXECUTABLE}
-
-import sys, os, re
-sys.path.append('${GR_RUNTIME_PYTHONPATH}')
-os.environ['srcdir'] = '${CMAKE_CURRENT_SOURCE_DIR}'
-os.chdir('${CMAKE_CURRENT_BINARY_DIR}')
-
-if __name__ == '__main__':
-    import build_utils
-    root, inp = sys.argv[1:3]
-    for sig in sys.argv[3:]:
-        name = re.sub ('X+', sig, root)
-        d = build_utils.standard_impl_dict2(name, sig, '${component}')
-        build_utils.expand_template(d, inp)
-")
-
-  #make a list of all the generated files
-  unset(expanded_files_cc)
-  unset(expanded_files_h)
-  foreach(sig ${ARGN})
-    string(REGEX REPLACE "X+" ${sig} name ${root})
-    list(APPEND expanded_files_cc ${CMAKE_CURRENT_BINARY_DIR}/${name}.cc)
-    list(APPEND expanded_files_h  ${CMAKE_CURRENT_BINARY_DIR}/${name}.h)
-  endforeach(sig)
-  unset(name)
-
-  #create a command to generate the source files
-  add_custom_command(
-    OUTPUT ${expanded_files_cc}
-    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}.cc.t
-    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
-    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-    ${root} ${root}.cc.t ${ARGN}
-  )
-
-  #create a command to generate the header files
-  add_custom_command(
-    OUTPUT ${expanded_files_h}
-    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}.h.t
-    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
-    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-    ${root} ${root}.h.t ${ARGN}
-  )
-
-  #make source files depends on headers to force generation
-  set_source_files_properties(${expanded_files_cc}
-    PROPERTIES OBJECT_DEPENDS "${expanded_files_h}"
-  )
-
-  #install rules for the generated files
-  list(APPEND generated_sources ${expanded_files_cc})
-  list(APPEND generated_headers ${expanded_files_h})
-
-endmacro(GR_EXPAND_X_CC_H)
-
-macro(GR_EXPAND_X_CC_H_IMPL component root)
-
-  include(GrPython)
-
-  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-"#!${PYTHON_EXECUTABLE}
-
-import sys, os, re
-sys.path.append('${GR_RUNTIME_PYTHONPATH}')
-os.environ['srcdir'] = '${CMAKE_CURRENT_SOURCE_DIR}'
-os.chdir('${CMAKE_CURRENT_BINARY_DIR}')
-
-if __name__ == '__main__':
-    import build_utils
-    root, inp = sys.argv[1:3]
-    for sig in sys.argv[3:]:
-        name = re.sub ('X+', sig, root)
-        d = build_utils.standard_dict(name, sig, '${component}')
-        build_utils.expand_template(d, inp, '_impl')
-")
-
-  #make a list of all the generated files
-  unset(expanded_files_cc_impl)
-  unset(expanded_files_h_impl)
-  unset(expanded_files_h)
-  foreach(sig ${ARGN})
-    string(REGEX REPLACE "X+" ${sig} name ${root})
-    list(APPEND expanded_files_cc_impl ${CMAKE_CURRENT_BINARY_DIR}/${name}_impl.cc)
-    list(APPEND expanded_files_h_impl ${CMAKE_CURRENT_BINARY_DIR}/${name}_impl.h)
-    list(APPEND expanded_files_h ${CMAKE_CURRENT_BINARY_DIR}/../include/gnuradio/${component}/${name}.h)
-  endforeach(sig)
-  unset(name)
-
-  #create a command to generate the _impl.cc files
-  add_custom_command(
-    OUTPUT ${expanded_files_cc_impl}
-    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}_impl.cc.t
-    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
-    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-    ${root} ${root}_impl.cc.t ${ARGN}
-  )
-
-  #create a command to generate the _impl.h files
-  add_custom_command(
-    OUTPUT ${expanded_files_h_impl}
-    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}_impl.h.t
-    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
-    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
-    ${root} ${root}_impl.h.t ${ARGN}
-  )
-
-  #make _impl.cc source files depend on _impl.h to force generation
-  set_source_files_properties(${expanded_files_cc_impl}
-    PROPERTIES OBJECT_DEPENDS "${expanded_files_h_impl}"
-  )
-
-  #make _impl.h source files depend on headers to force generation
-  set_source_files_properties(${expanded_files_h_impl}
-    PROPERTIES OBJECT_DEPENDS "${expanded_files_h}"
-  )
-
-  #install rules for the generated files
-  list(APPEND generated_sources ${expanded_files_cc_impl})
-  list(APPEND generated_headers ${expanded_files_h_impl})
-
-endmacro(GR_EXPAND_X_CC_H_IMPL)
diff -Nur src/gr-lora-0.6.2/cmake/Modules/GrPlatform.cmake gr-lora-0.6.2/cmake/Modules/GrPlatform.cmake
--- src/gr-lora-0.6.2/cmake/Modules/GrPlatform.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/GrPlatform.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,54 +0,0 @@
-# Copyright 2011 Free Software Foundation, Inc.
-#
-# This file is part of GNU Radio
-#
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
-#
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
-
-if(DEFINED __INCLUDED_GR_PLATFORM_CMAKE)
-    return()
-endif()
-set(__INCLUDED_GR_PLATFORM_CMAKE TRUE)
-
-########################################################################
-# Setup additional defines for OS types
-########################################################################
-if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
-    set(LINUX TRUE)
-endif()
-
-if(NOT CMAKE_CROSSCOMPILING AND LINUX AND EXISTS "/etc/debian_version")
-    set(DEBIAN TRUE)
-endif()
-
-if(NOT CMAKE_CROSSCOMPILING AND LINUX AND EXISTS "/etc/redhat-release")
-    set(REDHAT TRUE)
-endif()
-
-if(NOT CMAKE_CROSSCOMPILING AND LINUX AND EXISTS "/etc/slackware-version")
-    set(SLACKWARE TRUE)
-endif()
-
-########################################################################
-# when the library suffix should be 64 (applies to redhat linux family)
-########################################################################
-if (REDHAT OR SLACKWARE)
-    set(LIB64_CONVENTION TRUE)
-endif()
-
-if(NOT DEFINED LIB_SUFFIX AND LIB64_CONVENTION AND CMAKE_SYSTEM_PROCESSOR MATCHES "64$")
-    set(LIB_SUFFIX 64)
-endif()
-set(LIB_SUFFIX ${LIB_SUFFIX} CACHE STRING "lib directory suffix")
diff -Nur src/gr-lora-0.6.2/cmake/Modules/GrPython.cmake gr-lora-0.6.2/cmake/Modules/GrPython.cmake
--- src/gr-lora-0.6.2/cmake/Modules/GrPython.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/GrPython.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,241 +0,0 @@
-# Copyright 2010-2011 Free Software Foundation, Inc.
-#
-# This file is part of GNU Radio
-#
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
-#
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
-
-if(DEFINED __INCLUDED_GR_PYTHON_CMAKE)
-    return()
-endif()
-set(__INCLUDED_GR_PYTHON_CMAKE TRUE)
-
-########################################################################
-# Setup the python interpreter:
-# This allows the user to specify a specific interpreter,
-# or finds the interpreter via the built-in cmake module.
-########################################################################
-#this allows the user to override PYTHON_EXECUTABLE
-if(PYTHON_EXECUTABLE)
-
-    set(PYTHONINTERP_FOUND TRUE)
-
-#otherwise if not set, try to automatically find it
-else(PYTHON_EXECUTABLE)
-
-    #use the built-in find script
-    find_package(PythonInterp 2)
-
-    #and if that fails use the find program routine
-    if(NOT PYTHONINTERP_FOUND)
-        find_program(PYTHON_EXECUTABLE NAMES python python2 python2.7 python2.6 python2.5)
-        if(PYTHON_EXECUTABLE)
-            set(PYTHONINTERP_FOUND TRUE)
-        endif(PYTHON_EXECUTABLE)
-    endif(NOT PYTHONINTERP_FOUND)
-
-endif(PYTHON_EXECUTABLE)
-
-if (CMAKE_CROSSCOMPILING)
-    set(QA_PYTHON_EXECUTABLE "/usr/bin/python")
-else (CMAKE_CROSSCOMPILING)
-    set(QA_PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE})
-endif(CMAKE_CROSSCOMPILING)
-
-#make the path to the executable appear in the cmake gui
-set(PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE} CACHE FILEPATH "python interpreter")
-set(QA_PYTHON_EXECUTABLE ${QA_PYTHON_EXECUTABLE} CACHE FILEPATH "python interpreter for QA tests")
-
-#make sure we can use -B with python (introduced in 2.6)
-if(PYTHON_EXECUTABLE)
-    execute_process(
-        COMMAND ${PYTHON_EXECUTABLE} -B -c ""
-        OUTPUT_QUIET ERROR_QUIET
-        RESULT_VARIABLE PYTHON_HAS_DASH_B_RESULT
-    )
-    if(PYTHON_HAS_DASH_B_RESULT EQUAL 0)
-        set(PYTHON_DASH_B "-B")
-    endif()
-endif(PYTHON_EXECUTABLE)
-
-########################################################################
-# Check for the existence of a python module:
-# - desc a string description of the check
-# - mod the name of the module to import
-# - cmd an additional command to run
-# - have the result variable to set
-########################################################################
-macro(GR_PYTHON_CHECK_MODULE desc mod cmd have)
-    message(STATUS "")
-    message(STATUS "Python checking for ${desc}")
-    execute_process(
-        COMMAND ${PYTHON_EXECUTABLE} -c "
-#########################################
-try:
-    import ${mod}
-    assert ${cmd}
-except ImportError, AssertionError: exit(-1)
-except: pass
-#########################################"
-        RESULT_VARIABLE ${have}
-    )
-    if(${have} EQUAL 0)
-        message(STATUS "Python checking for ${desc} - found")
-        set(${have} TRUE)
-    else(${have} EQUAL 0)
-        message(STATUS "Python checking for ${desc} - not found")
-        set(${have} FALSE)
-    endif(${have} EQUAL 0)
-endmacro(GR_PYTHON_CHECK_MODULE)
-
-########################################################################
-# Sets the python installation directory GR_PYTHON_DIR
-########################################################################
-if(NOT DEFINED GR_PYTHON_DIR)
-execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "
-from distutils import sysconfig
-print sysconfig.get_python_lib(plat_specific=True, prefix='')
-" OUTPUT_VARIABLE GR_PYTHON_DIR OUTPUT_STRIP_TRAILING_WHITESPACE
-)
-endif()
-file(TO_CMAKE_PATH ${GR_PYTHON_DIR} GR_PYTHON_DIR)
-
-########################################################################
-# Create an always-built target with a unique name
-# Usage: GR_UNIQUE_TARGET(<description> <dependencies list>)
-########################################################################
-function(GR_UNIQUE_TARGET desc)
-    file(RELATIVE_PATH reldir ${CMAKE_BINARY_DIR} ${CMAKE_CURRENT_BINARY_DIR})
-    execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "import re, hashlib
-unique = hashlib.md5('${reldir}${ARGN}').hexdigest()[:5]
-print(re.sub('\\W', '_', '${desc} ${reldir} ' + unique))"
-    OUTPUT_VARIABLE _target OUTPUT_STRIP_TRAILING_WHITESPACE)
-    add_custom_target(${_target} ALL DEPENDS ${ARGN})
-endfunction(GR_UNIQUE_TARGET)
-
-########################################################################
-# Install python sources (also builds and installs byte-compiled python)
-########################################################################
-function(GR_PYTHON_INSTALL)
-    include(CMakeParseArgumentsCopy)
-    CMAKE_PARSE_ARGUMENTS(GR_PYTHON_INSTALL "" "DESTINATION;COMPONENT" "FILES;PROGRAMS" ${ARGN})
-
-    ####################################################################
-    if(GR_PYTHON_INSTALL_FILES)
-    ####################################################################
-        install(${ARGN}) #installs regular python files
-
-        #create a list of all generated files
-        unset(pysrcfiles)
-        unset(pycfiles)
-        unset(pyofiles)
-        foreach(pyfile ${GR_PYTHON_INSTALL_FILES})
-            get_filename_component(pyfile ${pyfile} ABSOLUTE)
-            list(APPEND pysrcfiles ${pyfile})
-
-            #determine if this file is in the source or binary directory
-            file(RELATIVE_PATH source_rel_path ${CMAKE_CURRENT_SOURCE_DIR} ${pyfile})
-            string(LENGTH "${source_rel_path}" source_rel_path_len)
-            file(RELATIVE_PATH binary_rel_path ${CMAKE_CURRENT_BINARY_DIR} ${pyfile})
-            string(LENGTH "${binary_rel_path}" binary_rel_path_len)
-
-            #and set the generated path appropriately
-            if(${source_rel_path_len} GREATER ${binary_rel_path_len})
-                set(pygenfile ${CMAKE_CURRENT_BINARY_DIR}/${binary_rel_path})
-            else()
-                set(pygenfile ${CMAKE_CURRENT_BINARY_DIR}/${source_rel_path})
-            endif()
-            list(APPEND pycfiles ${pygenfile}c)
-            list(APPEND pyofiles ${pygenfile}o)
-
-            #ensure generation path exists
-            get_filename_component(pygen_path ${pygenfile} PATH)
-            file(MAKE_DIRECTORY ${pygen_path})
-
-        endforeach(pyfile)
-
-        #the command to generate the pyc files
-        add_custom_command(
-            DEPENDS ${pysrcfiles} OUTPUT ${pycfiles}
-            COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_BINARY_DIR}/python_compile_helper.py ${pysrcfiles} ${pycfiles}
-        )
-
-        #the command to generate the pyo files
-        add_custom_command(
-            DEPENDS ${pysrcfiles} OUTPUT ${pyofiles}
-            COMMAND ${PYTHON_EXECUTABLE} -O ${CMAKE_BINARY_DIR}/python_compile_helper.py ${pysrcfiles} ${pyofiles}
-        )
-
-        #create install rule and add generated files to target list
-        set(python_install_gen_targets ${pycfiles} ${pyofiles})
-        install(FILES ${python_install_gen_targets}
-            DESTINATION ${GR_PYTHON_INSTALL_DESTINATION}
-            COMPONENT ${GR_PYTHON_INSTALL_COMPONENT}
-        )
-
-    ####################################################################
-    elseif(GR_PYTHON_INSTALL_PROGRAMS)
-    ####################################################################
-        file(TO_NATIVE_PATH ${PYTHON_EXECUTABLE} pyexe_native)
-
-        if (CMAKE_CROSSCOMPILING)
-           set(pyexe_native "/usr/bin/env python")
-        endif()
-
-        foreach(pyfile ${GR_PYTHON_INSTALL_PROGRAMS})
-            get_filename_component(pyfile_name ${pyfile} NAME)
-            get_filename_component(pyfile ${pyfile} ABSOLUTE)
-            string(REPLACE "${CMAKE_SOURCE_DIR}" "${CMAKE_BINARY_DIR}" pyexefile "${pyfile}.exe")
-            list(APPEND python_install_gen_targets ${pyexefile})
-
-            get_filename_component(pyexefile_path ${pyexefile} PATH)
-            file(MAKE_DIRECTORY ${pyexefile_path})
-
-            add_custom_command(
-                OUTPUT ${pyexefile} DEPENDS ${pyfile}
-                COMMAND ${PYTHON_EXECUTABLE} -c
-                "import re; R=re.compile('^\#!.*$\\n',flags=re.MULTILINE); open('${pyexefile}','w').write('\#!${pyexe_native}\\n'+R.sub('',open('${pyfile}','r').read()))"
-                COMMENT "Shebangin ${pyfile_name}"
-                VERBATIM
-            )
-
-            #on windows, python files need an extension to execute
-            get_filename_component(pyfile_ext ${pyfile} EXT)
-            if(WIN32 AND NOT pyfile_ext)
-                set(pyfile_name "${pyfile_name}.py")
-            endif()
-
-            install(PROGRAMS ${pyexefile} RENAME ${pyfile_name}
-                DESTINATION ${GR_PYTHON_INSTALL_DESTINATION}
-                COMPONENT ${GR_PYTHON_INSTALL_COMPONENT}
-            )
-        endforeach(pyfile)
-
-    endif()
-
-    GR_UNIQUE_TARGET("pygen" ${python_install_gen_targets})
-
-endfunction(GR_PYTHON_INSTALL)
-
-########################################################################
-# Write the python helper script that generates byte code files
-########################################################################
-file(WRITE ${CMAKE_BINARY_DIR}/python_compile_helper.py "
-import sys, py_compile
-files = sys.argv[1:]
-srcs, gens = files[:len(files)/2], files[len(files)/2:]
-for src, gen in zip(srcs, gens):
-    py_compile.compile(file=src, cfile=gen, doraise=True)
-")
diff -Nur src/gr-lora-0.6.2/cmake/Modules/GrSwig.cmake gr-lora-0.6.2/cmake/Modules/GrSwig.cmake
--- src/gr-lora-0.6.2/cmake/Modules/GrSwig.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/GrSwig.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,251 +0,0 @@
-# Copyright 2010-2011 Free Software Foundation, Inc.
-#
-# This file is part of GNU Radio
-#
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
-#
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
-
-if(DEFINED __INCLUDED_GR_SWIG_CMAKE)
-    return()
-endif()
-set(__INCLUDED_GR_SWIG_CMAKE TRUE)
-
-include(GrPython)
-
-########################################################################
-# Builds a swig documentation file to be generated into python docstrings
-# Usage: GR_SWIG_MAKE_DOCS(output_file input_path input_path....)
-#
-# Set the following variable to specify extra dependent targets:
-#   - GR_SWIG_DOCS_SOURCE_DEPS
-#   - GR_SWIG_DOCS_TARGET_DEPS
-########################################################################
-function(GR_SWIG_MAKE_DOCS output_file)
-    if(ENABLE_DOXYGEN)
-
-        #setup the input files variable list, quote formated
-        set(input_files)
-        unset(INPUT_PATHS)
-        foreach(input_path ${ARGN})
-            if(IS_DIRECTORY ${input_path}) #when input path is a directory
-                file(GLOB input_path_h_files ${input_path}/*.h)
-            else() #otherwise its just a file, no glob
-                set(input_path_h_files ${input_path})
-            endif()
-            list(APPEND input_files ${input_path_h_files})
-            set(INPUT_PATHS "${INPUT_PATHS} \"${input_path}\"")
-        endforeach(input_path)
-
-        #determine the output directory
-        get_filename_component(name ${output_file} NAME_WE)
-        get_filename_component(OUTPUT_DIRECTORY ${output_file} PATH)
-        set(OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY}/${name}_swig_docs)
-        make_directory(${OUTPUT_DIRECTORY})
-
-        #generate the Doxyfile used by doxygen
-        configure_file(
-            ${CMAKE_SOURCE_DIR}/docs/doxygen/Doxyfile.swig_doc.in
-            ${OUTPUT_DIRECTORY}/Doxyfile
-        @ONLY)
-
-        #Create a dummy custom command that depends on other targets
-        include(GrMiscUtils)
-        GR_GEN_TARGET_DEPS(_${name}_tag tag_deps ${GR_SWIG_DOCS_TARGET_DEPS})
-
-        #call doxygen on the Doxyfile + input headers
-        add_custom_command(
-            OUTPUT ${OUTPUT_DIRECTORY}/xml/index.xml
-            DEPENDS ${input_files} ${GR_SWIG_DOCS_SOURCE_DEPS} ${tag_deps}
-            COMMAND ${DOXYGEN_EXECUTABLE} ${OUTPUT_DIRECTORY}/Doxyfile
-            COMMENT "Generating doxygen xml for ${name} docs"
-        )
-
-        #call the swig_doc script on the xml files
-        add_custom_command(
-            OUTPUT ${output_file}
-            DEPENDS ${input_files} ${stamp-file} ${OUTPUT_DIRECTORY}/xml/index.xml
-            COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
-                ${CMAKE_SOURCE_DIR}/docs/doxygen/swig_doc.py
-                ${OUTPUT_DIRECTORY}/xml
-                ${output_file}
-            COMMENT "Generating python docstrings for ${name}"
-            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/docs/doxygen
-        )
-
-    else(ENABLE_DOXYGEN)
-        file(WRITE ${output_file} "\n") #no doxygen -> empty file
-    endif(ENABLE_DOXYGEN)
-endfunction(GR_SWIG_MAKE_DOCS)
-
-########################################################################
-# Build a swig target for the common gnuradio use case. Usage:
-# GR_SWIG_MAKE(target ifile ifile ifile...)
-#
-# Set the following variables before calling:
-#   - GR_SWIG_FLAGS
-#   - GR_SWIG_INCLUDE_DIRS
-#   - GR_SWIG_LIBRARIES
-#   - GR_SWIG_SOURCE_DEPS
-#   - GR_SWIG_TARGET_DEPS
-#   - GR_SWIG_DOC_FILE
-#   - GR_SWIG_DOC_DIRS
-########################################################################
-macro(GR_SWIG_MAKE name)
-    set(ifiles ${ARGN})
-
-    # Shimming this in here to take care of a SWIG bug with handling
-    # vector<size_t> and vector<unsigned int> (on 32-bit machines) and
-    # vector<long unsigned int> (on 64-bit machines). Use this to test
-    # the size of size_t, then set SIZE_T_32 if it's a 32-bit machine
-    # or not if it's 64-bit. The logic in gr_type.i handles the rest.
-    INCLUDE(CheckTypeSize)
-    CHECK_TYPE_SIZE("size_t" SIZEOF_SIZE_T)
-    CHECK_TYPE_SIZE("unsigned int" SIZEOF_UINT)
-    if(${SIZEOF_SIZE_T} EQUAL ${SIZEOF_UINT})
-      list(APPEND GR_SWIG_FLAGS -DSIZE_T_32)
-    endif(${SIZEOF_SIZE_T} EQUAL ${SIZEOF_UINT})
-
-    #do swig doc generation if specified
-    if(GR_SWIG_DOC_FILE)
-        set(GR_SWIG_DOCS_SOURCE_DEPS ${GR_SWIG_SOURCE_DEPS})
-        list(APPEND GR_SWIG_DOCS_TARGET_DEPS ${GR_SWIG_TARGET_DEPS})
-        GR_SWIG_MAKE_DOCS(${GR_SWIG_DOC_FILE} ${GR_SWIG_DOC_DIRS})
-        add_custom_target(${name}_swig_doc DEPENDS ${GR_SWIG_DOC_FILE})
-        list(APPEND GR_SWIG_TARGET_DEPS ${name}_swig_doc ${GR_RUNTIME_SWIG_DOC_FILE})
-    endif()
-
-    #append additional include directories
-    find_package(PythonLibs 2)
-    list(APPEND GR_SWIG_INCLUDE_DIRS ${PYTHON_INCLUDE_PATH}) #deprecated name (now dirs)
-    list(APPEND GR_SWIG_INCLUDE_DIRS ${PYTHON_INCLUDE_DIRS})
-
-    #prepend local swig directories
-    list(INSERT GR_SWIG_INCLUDE_DIRS 0 ${CMAKE_CURRENT_SOURCE_DIR})
-    list(INSERT GR_SWIG_INCLUDE_DIRS 0 ${CMAKE_CURRENT_BINARY_DIR})
-
-    #determine include dependencies for swig file
-    execute_process(
-        COMMAND ${PYTHON_EXECUTABLE}
-            ${CMAKE_BINARY_DIR}/get_swig_deps.py
-            "${ifiles}" "${GR_SWIG_INCLUDE_DIRS}"
-        OUTPUT_STRIP_TRAILING_WHITESPACE
-        OUTPUT_VARIABLE SWIG_MODULE_${name}_EXTRA_DEPS
-        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
-    )
-
-    #Create a dummy custom command that depends on other targets
-    include(GrMiscUtils)
-    GR_GEN_TARGET_DEPS(_${name}_swig_tag tag_deps ${GR_SWIG_TARGET_DEPS})
-    set(tag_file ${CMAKE_CURRENT_BINARY_DIR}/${name}.tag)
-    add_custom_command(
-        OUTPUT ${tag_file}
-        DEPENDS ${GR_SWIG_SOURCE_DEPS} ${tag_deps}
-        COMMAND ${CMAKE_COMMAND} -E touch ${tag_file}
-    )
-
-    #append the specified include directories
-    include_directories(${GR_SWIG_INCLUDE_DIRS})
-    list(APPEND SWIG_MODULE_${name}_EXTRA_DEPS ${tag_file})
-
-    #setup the swig flags with flags and include directories
-    set(CMAKE_SWIG_FLAGS -fvirtual -modern -keyword -w511 -module ${name} ${GR_SWIG_FLAGS})
-    foreach(dir ${GR_SWIG_INCLUDE_DIRS})
-        list(APPEND CMAKE_SWIG_FLAGS "-I${dir}")
-    endforeach(dir)
-
-    #set the C++ property on the swig .i file so it builds
-    set_source_files_properties(${ifiles} PROPERTIES CPLUSPLUS ON)
-
-    #setup the actual swig library target to be built
-    include(UseSWIG)
-    SWIG_ADD_MODULE(${name} python ${ifiles})
-    SWIG_LINK_LIBRARIES(${name} ${PYTHON_LIBRARIES} ${GR_SWIG_LIBRARIES})
-    if(${name} STREQUAL "runtime_swig")
-        SET_TARGET_PROPERTIES(${SWIG_MODULE_runtime_swig_REAL_NAME} PROPERTIES DEFINE_SYMBOL "gnuradio_runtime_EXPORTS")
-    endif(${name} STREQUAL "runtime_swig")
-
-endmacro(GR_SWIG_MAKE)
-
-########################################################################
-# Install swig targets generated by GR_SWIG_MAKE. Usage:
-# GR_SWIG_INSTALL(
-#   TARGETS target target target...
-#   [DESTINATION destination]
-#   [COMPONENT component]
-# )
-########################################################################
-macro(GR_SWIG_INSTALL)
-
-    include(CMakeParseArgumentsCopy)
-    CMAKE_PARSE_ARGUMENTS(GR_SWIG_INSTALL "" "DESTINATION;COMPONENT" "TARGETS" ${ARGN})
-
-    foreach(name ${GR_SWIG_INSTALL_TARGETS})
-        install(TARGETS ${SWIG_MODULE_${name}_REAL_NAME}
-            DESTINATION ${GR_SWIG_INSTALL_DESTINATION}
-            COMPONENT ${GR_SWIG_INSTALL_COMPONENT}
-        )
-
-        include(GrPython)
-        GR_PYTHON_INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/${name}.py
-            DESTINATION ${GR_SWIG_INSTALL_DESTINATION}
-            COMPONENT ${GR_SWIG_INSTALL_COMPONENT}
-        )
-
-        GR_LIBTOOL(
-            TARGET ${SWIG_MODULE_${name}_REAL_NAME}
-            DESTINATION ${GR_SWIG_INSTALL_DESTINATION}
-        )
-
-    endforeach(name)
-
-endmacro(GR_SWIG_INSTALL)
-
-########################################################################
-# Generate a python file that can determine swig dependencies.
-# Used by the make macro above to determine extra dependencies.
-# When you build C++, CMake figures out the header dependencies.
-# This code essentially performs that logic for swig includes.
-########################################################################
-file(WRITE ${CMAKE_BINARY_DIR}/get_swig_deps.py "
-
-import os, sys, re
-
-i_include_matcher = re.compile('%(include|import)\\s*[<|\"](.*)[>|\"]')
-h_include_matcher = re.compile('#(include)\\s*[<|\"](.*)[>|\"]')
-include_dirs = sys.argv[2].split(';')
-
-def get_swig_incs(file_path):
-    if file_path.endswith('.i'): matcher = i_include_matcher
-    else: matcher = h_include_matcher
-    file_contents = open(file_path, 'r').read()
-    return matcher.findall(file_contents, re.MULTILINE)
-
-def get_swig_deps(file_path, level):
-    deps = [file_path]
-    if level == 0: return deps
-    for keyword, inc_file in get_swig_incs(file_path):
-        for inc_dir in include_dirs:
-            inc_path = os.path.join(inc_dir, inc_file)
-            if not os.path.exists(inc_path): continue
-            deps.extend(get_swig_deps(inc_path, level-1))
-            break #found, we dont search in lower prio inc dirs
-    return deps
-
-if __name__ == '__main__':
-    ifiles = sys.argv[1].split(';')
-    deps = sum([get_swig_deps(ifile, 3) for ifile in ifiles], [])
-    #sys.stderr.write(';'.join(set(deps)) + '\\n\\n')
-    print(';'.join(set(deps)))
-")
diff -Nur src/gr-lora-0.6.2/cmake/Modules/GrTest.cmake gr-lora-0.6.2/cmake/Modules/GrTest.cmake
--- src/gr-lora-0.6.2/cmake/Modules/GrTest.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/GrTest.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,143 +0,0 @@
-# Copyright 2010-2011 Free Software Foundation, Inc.
-#
-# This file is part of GNU Radio
-#
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
-#
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
-
-if(DEFINED __INCLUDED_GR_TEST_CMAKE)
-    return()
-endif()
-set(__INCLUDED_GR_TEST_CMAKE TRUE)
-
-########################################################################
-# Add a unit test and setup the environment for a unit test.
-# Takes the same arguments as the ADD_TEST function.
-#
-# Before calling set the following variables:
-# GR_TEST_TARGET_DEPS  - built targets for the library path
-# GR_TEST_LIBRARY_DIRS - directories for the library path
-# GR_TEST_PYTHON_DIRS  - directories for the python path
-# GR_TEST_ENVIRONS  - other environment key/value pairs
-########################################################################
-function(GR_ADD_TEST test_name)
-
-        #Ensure that the build exe also appears in the PATH.
-        list(APPEND GR_TEST_TARGET_DEPS ${ARGN})
-
-        #In the land of windows, all libraries must be in the PATH.
-        #Since the dependent libraries are not yet installed,
-        #we must manually set them in the PATH to run tests.
-        #The following appends the path of a target dependency.
-        foreach(target ${GR_TEST_TARGET_DEPS})
-            get_target_property(location ${target} LOCATION)
-            if(location)
-                get_filename_component(path ${location} PATH)
-                string(REGEX REPLACE "\\$\\(.*\\)" ${CMAKE_BUILD_TYPE} path ${path})
-                list(APPEND GR_TEST_LIBRARY_DIRS ${path})
-            endif(location)
-        endforeach(target)
-
-    if(WIN32)
-        #SWIG generates the python library files into a subdirectory.
-        #Therefore, we must append this subdirectory into PYTHONPATH.
-        #Only do this for the python directories matching the following:
-        foreach(pydir ${GR_TEST_PYTHON_DIRS})
-            get_filename_component(name ${pydir} NAME)
-            if(name MATCHES "^(swig|lib|src)$")
-                list(APPEND GR_TEST_PYTHON_DIRS ${pydir}/${CMAKE_BUILD_TYPE})
-            endif()
-        endforeach(pydir)
-    endif(WIN32)
-
-    file(TO_NATIVE_PATH ${CMAKE_CURRENT_SOURCE_DIR} srcdir)
-    file(TO_NATIVE_PATH "${GR_TEST_LIBRARY_DIRS}" libpath) #ok to use on dir list?
-    file(TO_NATIVE_PATH "${GR_TEST_PYTHON_DIRS}" pypath) #ok to use on dir list?
-
-    set(environs "VOLK_GENERIC=1" "GR_DONT_LOAD_PREFS=1" "srcdir=${srcdir}")
-    list(APPEND environs ${GR_TEST_ENVIRONS})
-
-    #http://www.cmake.org/pipermail/cmake/2009-May/029464.html
-    #Replaced this add test + set environs code with the shell script generation.
-    #Its nicer to be able to manually run the shell script to diagnose problems.
-    #ADD_TEST(${ARGV})
-    #SET_TESTS_PROPERTIES(${test_name} PROPERTIES ENVIRONMENT "${environs}")
-
-    if(UNIX)
-        set(LD_PATH_VAR "LD_LIBRARY_PATH")
-        if(APPLE)
-            set(LD_PATH_VAR "DYLD_LIBRARY_PATH")
-        endif()
-
-        set(binpath "${CMAKE_CURRENT_BINARY_DIR}:$PATH")
-        list(APPEND libpath "$${LD_PATH_VAR}")
-        list(APPEND pypath "$PYTHONPATH")
-
-        #replace list separator with the path separator
-        string(REPLACE ";" ":" libpath "${libpath}")
-        string(REPLACE ";" ":" pypath "${pypath}")
-        list(APPEND environs "PATH=${binpath}" "${LD_PATH_VAR}=${libpath}" "PYTHONPATH=${pypath}")
-
-        #generate a bat file that sets the environment and runs the test
-	if (CMAKE_CROSSCOMPILING)
-                set(SHELL "/bin/sh")
-        else(CMAKE_CROSSCOMPILING)
-                find_program(SHELL sh)
-        endif(CMAKE_CROSSCOMPILING)
-        set(sh_file ${CMAKE_CURRENT_BINARY_DIR}/${test_name}_test.sh)
-        file(WRITE ${sh_file} "#!${SHELL}\n")
-        #each line sets an environment variable
-        foreach(environ ${environs})
-            file(APPEND ${sh_file} "export ${environ}\n")
-        endforeach(environ)
-        #load the command to run with its arguments
-        foreach(arg ${ARGN})
-            file(APPEND ${sh_file} "${arg} ")
-        endforeach(arg)
-        file(APPEND ${sh_file} "\n")
-
-        #make the shell file executable
-        execute_process(COMMAND chmod +x ${sh_file})
-
-        add_test(${test_name} ${SHELL} ${sh_file})
-
-    endif(UNIX)
-
-    if(WIN32)
-        list(APPEND libpath ${DLL_PATHS} "%PATH%")
-        list(APPEND pypath "%PYTHONPATH%")
-
-        #replace list separator with the path separator (escaped)
-        string(REPLACE ";" "\\;" libpath "${libpath}")
-        string(REPLACE ";" "\\;" pypath "${pypath}")
-        list(APPEND environs "PATH=${libpath}" "PYTHONPATH=${pypath}")
-
-        #generate a bat file that sets the environment and runs the test
-        set(bat_file ${CMAKE_CURRENT_BINARY_DIR}/${test_name}_test.bat)
-        file(WRITE ${bat_file} "@echo off\n")
-        #each line sets an environment variable
-        foreach(environ ${environs})
-            file(APPEND ${bat_file} "SET ${environ}\n")
-        endforeach(environ)
-        #load the command to run with its arguments
-        foreach(arg ${ARGN})
-            file(APPEND ${bat_file} "${arg} ")
-        endforeach(arg)
-        file(APPEND ${bat_file} "\n")
-
-        add_test(${test_name} ${bat_file})
-    endif(WIN32)
-
-endfunction(GR_ADD_TEST)
diff -Nur src/gr-lora-0.6.2/cmake/Modules/UseSWIG.cmake gr-lora-0.6.2/cmake/Modules/UseSWIG.cmake
--- src/gr-lora-0.6.2/cmake/Modules/UseSWIG.cmake	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/cmake/Modules/UseSWIG.cmake	1970-01-01 00:00:00.000000000 +0000
@@ -1,304 +0,0 @@
-# - SWIG module for CMake
-# Defines the following macros:
-#   SWIG_ADD_MODULE(name language [ files ])
-#     - Define swig module with given name and specified language
-#   SWIG_LINK_LIBRARIES(name [ libraries ])
-#     - Link libraries to swig module
-# All other macros are for internal use only.
-# To get the actual name of the swig module,
-# use: ${SWIG_MODULE_${name}_REAL_NAME}.
-# Set Source files properties such as CPLUSPLUS and SWIG_FLAGS to specify
-# special behavior of SWIG. Also global CMAKE_SWIG_FLAGS can be used to add
-# special flags to all swig calls.
-# Another special variable is CMAKE_SWIG_OUTDIR, it allows one to specify
-# where to write all the swig generated module (swig -outdir option)
-# The name-specific variable SWIG_MODULE_<name>_EXTRA_DEPS may be used
-# to specify extra dependencies for the generated modules.
-# If the source file generated by swig need some special flag you can use
-# set_source_files_properties( ${swig_generated_file_fullname}
-#        PROPERTIES COMPILE_FLAGS "-bla")
-
-
-#=============================================================================
-# Copyright 2004-2009 Kitware, Inc.
-# Copyright 2009 Mathieu Malaterre <mathieu.malaterre@gmail.com>
-#
-# Distributed under the OSI-approved BSD License (the "License");
-# see accompanying file Copyright.txt for details.
-#
-# This software is distributed WITHOUT ANY WARRANTY; without even the
-# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-# See the License for more information.
-#=============================================================================
-# (To distribute this file outside of CMake, substitute the full
-#  License text for the above reference.)
-
-set(SWIG_CXX_EXTENSION "cxx")
-set(SWIG_EXTRA_LIBRARIES "")
-
-set(SWIG_PYTHON_EXTRA_FILE_EXTENSION "py")
-
-#
-# For given swig module initialize variables associated with it
-#
-macro(SWIG_MODULE_INITIALIZE name language)
-  string(TOUPPER "${language}" swig_uppercase_language)
-  string(TOLOWER "${language}" swig_lowercase_language)
-  set(SWIG_MODULE_${name}_LANGUAGE "${swig_uppercase_language}")
-  set(SWIG_MODULE_${name}_SWIG_LANGUAGE_FLAG "${swig_lowercase_language}")
-
-  set(SWIG_MODULE_${name}_REAL_NAME "${name}")
-  if("${SWIG_MODULE_${name}_LANGUAGE}" STREQUAL "UNKNOWN")
-    message(FATAL_ERROR "SWIG Error: Language \"${language}\" not found")
-  elseif("${SWIG_MODULE_${name}_LANGUAGE}" STREQUAL "PYTHON")
-    # when swig is used without the -interface it will produce in the module.py
-    # a 'import _modulename' statement, which implies having a corresponding
-    # _modulename.so (*NIX), _modulename.pyd (Win32).
-    set(SWIG_MODULE_${name}_REAL_NAME "_${name}")
-  elseif("${SWIG_MODULE_${name}_LANGUAGE}" STREQUAL "PERL")
-    set(SWIG_MODULE_${name}_EXTRA_FLAGS "-shadow")
-  endif()
-endmacro()
-
-#
-# For a given language, input file, and output file, determine extra files that
-# will be generated. This is internal swig macro.
-#
-
-macro(SWIG_GET_EXTRA_OUTPUT_FILES language outfiles generatedpath infile)
-  set(${outfiles} "")
-  get_source_file_property(SWIG_GET_EXTRA_OUTPUT_FILES_module_basename
-    ${infile} SWIG_MODULE_NAME)
-  if(SWIG_GET_EXTRA_OUTPUT_FILES_module_basename STREQUAL "NOTFOUND")
-    get_filename_component(SWIG_GET_EXTRA_OUTPUT_FILES_module_basename "${infile}" NAME_WE)
-  endif()
-  foreach(it ${SWIG_${language}_EXTRA_FILE_EXTENSION})
-    set(${outfiles} ${${outfiles}}
-      "${generatedpath}/${SWIG_GET_EXTRA_OUTPUT_FILES_module_basename}.${it}")
-  endforeach()
-endmacro()
-
-#
-# Take swig (*.i) file and add proper custom commands for it
-#
-macro(SWIG_ADD_SOURCE_TO_MODULE name outfiles infile)
-  set(swig_full_infile ${infile})
-  get_filename_component(swig_source_file_path "${infile}" PATH)
-  get_filename_component(swig_source_file_name_we "${infile}" NAME_WE)
-  get_source_file_property(swig_source_file_generated ${infile} GENERATED)
-  get_source_file_property(swig_source_file_cplusplus ${infile} CPLUSPLUS)
-  get_source_file_property(swig_source_file_flags ${infile} SWIG_FLAGS)
-  if("${swig_source_file_flags}" STREQUAL "NOTFOUND")
-    set(swig_source_file_flags "")
-  endif()
-  set(swig_source_file_fullname "${infile}")
-  if(${swig_source_file_path} MATCHES "^${CMAKE_CURRENT_SOURCE_DIR}")
-    string(REGEX REPLACE
-      "^${CMAKE_CURRENT_SOURCE_DIR}" ""
-      swig_source_file_relative_path
-      "${swig_source_file_path}")
-  else()
-    if(${swig_source_file_path} MATCHES "^${CMAKE_CURRENT_BINARY_DIR}")
-      string(REGEX REPLACE
-        "^${CMAKE_CURRENT_BINARY_DIR}" ""
-        swig_source_file_relative_path
-        "${swig_source_file_path}")
-      set(swig_source_file_generated 1)
-    else()
-      set(swig_source_file_relative_path "${swig_source_file_path}")
-      if(swig_source_file_generated)
-        set(swig_source_file_fullname "${CMAKE_CURRENT_BINARY_DIR}/${infile}")
-      else()
-        set(swig_source_file_fullname "${CMAKE_CURRENT_SOURCE_DIR}/${infile}")
-      endif()
-    endif()
-  endif()
-
-  set(swig_generated_file_fullname
-    "${CMAKE_CURRENT_BINARY_DIR}")
-  if(swig_source_file_relative_path)
-    set(swig_generated_file_fullname
-      "${swig_generated_file_fullname}/${swig_source_file_relative_path}")
-  endif()
-  # If CMAKE_SWIG_OUTDIR was specified then pass it to -outdir
-  if(CMAKE_SWIG_OUTDIR)
-    set(swig_outdir ${CMAKE_SWIG_OUTDIR})
-  else()
-    set(swig_outdir ${CMAKE_CURRENT_BINARY_DIR})
-  endif()
-  SWIG_GET_EXTRA_OUTPUT_FILES(${SWIG_MODULE_${name}_LANGUAGE}
-    swig_extra_generated_files
-    "${swig_outdir}"
-    "${infile}")
-  set(swig_generated_file_fullname
-    "${swig_generated_file_fullname}/${swig_source_file_name_we}")
-  # add the language into the name of the file (i.e. TCL_wrap)
-  # this allows for the same .i file to be wrapped into different languages
-  set(swig_generated_file_fullname
-    "${swig_generated_file_fullname}${SWIG_MODULE_${name}_LANGUAGE}_wrap")
-
-  if(swig_source_file_cplusplus)
-    set(swig_generated_file_fullname
-      "${swig_generated_file_fullname}.${SWIG_CXX_EXTENSION}")
-  else()
-    set(swig_generated_file_fullname
-      "${swig_generated_file_fullname}.c")
-  endif()
-
-  # Shut up some warnings from poor SWIG code generation that we
-  # can do nothing about, when this flag is available
-  include(CheckCXXCompilerFlag)
-  check_cxx_compiler_flag("-Wno-unused-but-set-variable" HAVE_WNO_UNUSED_BUT_SET_VARIABLE)
-  if(HAVE_WNO_UNUSED_BUT_SET_VARIABLE)
-    set_source_files_properties(${swig_generated_file_fullname}
-      PROPERTIES COMPILE_FLAGS "-Wno-unused-but-set-variable")
-  endif(HAVE_WNO_UNUSED_BUT_SET_VARIABLE)
-
-  get_directory_property(cmake_include_directories INCLUDE_DIRECTORIES)
-  set(swig_include_dirs)
-  foreach(it ${cmake_include_directories})
-    set(swig_include_dirs ${swig_include_dirs} "-I${it}")
-  endforeach()
-
-  set(swig_special_flags)
-  # default is c, so add c++ flag if it is c++
-  if(swig_source_file_cplusplus)
-    set(swig_special_flags ${swig_special_flags} "-c++")
-  endif()
-  set(swig_extra_flags)
-  if(SWIG_MODULE_${name}_EXTRA_FLAGS)
-    set(swig_extra_flags ${swig_extra_flags} ${SWIG_MODULE_${name}_EXTRA_FLAGS})
-  endif()
-
-  # hack to work around CMake bug in add_custom_command with multiple OUTPUT files
-
-  file(RELATIVE_PATH reldir ${CMAKE_BINARY_DIR} ${CMAKE_CURRENT_BINARY_DIR})
-  execute_process(
-    COMMAND ${PYTHON_EXECUTABLE} -c "import re, hashlib
-unique = hashlib.md5('${reldir}${ARGN}').hexdigest()[:5]
-print(re.sub('\\W', '_', '${name} ${reldir} ' + unique))"
-    OUTPUT_VARIABLE _target OUTPUT_STRIP_TRAILING_WHITESPACE
-  )
-
-  file(
-    WRITE ${CMAKE_CURRENT_BINARY_DIR}/${_target}.cpp.in
-   "int main(void){return 0;}\n"
-  )
-
-  # create dummy dependencies
-  add_custom_command(
-    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${_target}.cpp
-    COMMAND ${CMAKE_COMMAND} -E copy
-        ${CMAKE_CURRENT_BINARY_DIR}/${_target}.cpp.in
-        ${CMAKE_CURRENT_BINARY_DIR}/${_target}.cpp
-    DEPENDS "${swig_source_file_fullname}" ${SWIG_MODULE_${name}_EXTRA_DEPS}
-    COMMENT ""
-  )
-
-  # create the dummy target
-  add_executable(${_target} ${CMAKE_CURRENT_BINARY_DIR}/${_target}.cpp)
-
-  # add a custom command to the dummy target
-  add_custom_command(
-    TARGET ${_target}
-    # Let's create the ${swig_outdir} at execution time, in case dir contains $(OutDir)
-    COMMAND ${CMAKE_COMMAND} -E make_directory ${swig_outdir}
-    COMMAND "${SWIG_EXECUTABLE}"
-    ARGS "-${SWIG_MODULE_${name}_SWIG_LANGUAGE_FLAG}"
-    ${swig_source_file_flags}
-    ${CMAKE_SWIG_FLAGS}
-    -outdir ${swig_outdir}
-    ${swig_special_flags}
-    ${swig_extra_flags}
-    ${swig_include_dirs}
-    -o "${swig_generated_file_fullname}"
-    "${swig_source_file_fullname}"
-    COMMENT "Swig source"
-  )
-
-  #add dummy independent dependencies from the _target to each file
-  #that will be generated by the SWIG command above
-
-  set(${outfiles} "${swig_generated_file_fullname}" ${swig_extra_generated_files})
-
-  foreach(swig_gen_file ${${outfiles}})
-    add_custom_command(
-      OUTPUT ${swig_gen_file}
-      COMMAND ""
-      DEPENDS ${_target}
-      COMMENT ""
-    )
-  endforeach()
-
-  set_source_files_properties(
-    ${outfiles} PROPERTIES GENERATED 1
-  )
-
-endmacro()
-
-#
-# Create Swig module
-#
-macro(SWIG_ADD_MODULE name language)
-  SWIG_MODULE_INITIALIZE(${name} ${language})
-  set(swig_dot_i_sources)
-  set(swig_other_sources)
-  foreach(it ${ARGN})
-    if(${it} MATCHES ".*\\.i$")
-      set(swig_dot_i_sources ${swig_dot_i_sources} "${it}")
-    else()
-      set(swig_other_sources ${swig_other_sources} "${it}")
-    endif()
-  endforeach()
-
-  set(swig_generated_sources)
-  foreach(it ${swig_dot_i_sources})
-    SWIG_ADD_SOURCE_TO_MODULE(${name} swig_generated_source ${it})
-    set(swig_generated_sources ${swig_generated_sources} "${swig_generated_source}")
-  endforeach()
-  get_directory_property(swig_extra_clean_files ADDITIONAL_MAKE_CLEAN_FILES)
-  set_directory_properties(PROPERTIES
-    ADDITIONAL_MAKE_CLEAN_FILES "${swig_extra_clean_files};${swig_generated_sources}")
-  add_library(${SWIG_MODULE_${name}_REAL_NAME}
-    MODULE
-    ${swig_generated_sources}
-    ${swig_other_sources})
-  string(TOLOWER "${language}" swig_lowercase_language)
-  if ("${swig_lowercase_language}" STREQUAL "java")
-    if (APPLE)
-        # In java you want:
-        #      System.loadLibrary("LIBRARY");
-        # then JNI will look for a library whose name is platform dependent, namely
-        #   MacOS  : libLIBRARY.jnilib
-        #   Windows: LIBRARY.dll
-        #   Linux  : libLIBRARY.so
-        set_target_properties (${SWIG_MODULE_${name}_REAL_NAME} PROPERTIES SUFFIX ".jnilib")
-      endif ()
-  endif ()
-  if ("${swig_lowercase_language}" STREQUAL "python")
-    # this is only needed for the python case where a _modulename.so is generated
-    set_target_properties(${SWIG_MODULE_${name}_REAL_NAME} PROPERTIES PREFIX "")
-    # Python extension modules on Windows must have the extension ".pyd"
-    # instead of ".dll" as of Python 2.5.  Older python versions do support
-    # this suffix.
-    # http://docs.python.org/whatsnew/ports.html#SECTION0001510000000000000000
-    # <quote>
-    # Windows: .dll is no longer supported as a filename extension for extension modules.
-    # .pyd is now the only filename extension that will be searched for.
-    # </quote>
-    if(WIN32 AND NOT CYGWIN)
-      set_target_properties(${SWIG_MODULE_${name}_REAL_NAME} PROPERTIES SUFFIX ".pyd")
-    endif()
-  endif ()
-endmacro()
-
-#
-# Like TARGET_LINK_LIBRARIES but for swig modules
-#
-macro(SWIG_LINK_LIBRARIES name)
-  if(SWIG_MODULE_${name}_REAL_NAME)
-    target_link_libraries(${SWIG_MODULE_${name}_REAL_NAME} ${ARGN})
-  else()
-    message(SEND_ERROR "Cannot find Swig library \"${name}\".")
-  endif()
-endmacro()
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/__init__.py gr-lora-0.6.2/docs/doxygen/doxyxml/__init__.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/__init__.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/__init__.py	2019-08-14 23:20:45.290000000 +0000
@@ -64,7 +64,7 @@
 
 """
 
-from doxyindex import DoxyIndex, DoxyFunction, DoxyParam, DoxyClass, DoxyFile, DoxyNamespace, DoxyGroup, DoxyFriend, DoxyOther
+from .doxyindex import DoxyIndex, DoxyFunction, DoxyParam, DoxyClass, DoxyFile, DoxyNamespace, DoxyGroup, DoxyFriend, DoxyOther
 
 def _test():
     import os
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/base.py gr-lora-0.6.2/docs/doxygen/doxyxml/base.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/base.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/base.py	2019-08-14 23:20:45.290000000 +0000
@@ -24,24 +24,26 @@
 Classes based upon this are used to make more user-friendly interfaces
 to the doxygen xml docs than the generated classes provide.
 """
+from __future__ import print_function
+from __future__ import unicode_literals
 
 import os
 import pdb
 
 from xml.parsers.expat import ExpatError
 
-from generated import compound
+from .generated import compound
 
 
 class Base(object):
 
-    class Duplicate(StandardError):
+    class Duplicate(Exception):
         pass
 
-    class NoSuchMember(StandardError):
+    class NoSuchMember(Exception):
         pass
 
-    class ParsingError(StandardError):
+    class ParsingError(Exception):
         pass
 
     def __init__(self, parse_data, top=None):
@@ -94,7 +96,7 @@
         for cls in self.mem_classes:
             if cls.can_parse(mem):
                 return cls
-        raise StandardError(("Did not find a class for object '%s'." \
+        raise Exception(("Did not find a class for object '%s'." \
                                  % (mem.get_name())))
 
     def convert_mem(self, mem):
@@ -102,11 +104,11 @@
             cls = self.get_cls(mem)
             converted = cls.from_parse_data(mem, self.top)
             if converted is None:
-                raise StandardError('No class matched this object.')
+                raise Exception('No class matched this object.')
             self.add_ref(converted)
             return converted
-        except StandardError, e:
-            print e
+        except Exception as e:
+            print(e)
 
     @classmethod
     def includes(cls, inst):
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/doxyindex.py gr-lora-0.6.2/docs/doxygen/doxyxml/doxyindex.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/doxyindex.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/doxyindex.py	2019-08-14 23:25:47.030000000 +0000
@@ -22,12 +22,14 @@
 Classes providing more user-friendly interfaces to the doxygen xml
 docs than the generated classes provide.
 """
+from __future__ import absolute_import
+from __future__ import unicode_literals
 
 import os
 
-from generated import index
-from base import Base
-from text import description
+from .generated import index
+from .base import Base
+from .text import description
 
 class DoxyIndex(Base):
     """
@@ -50,6 +52,9 @@
                 if mem.name.endswith('.h'):
                     self._members += converted.members()
                     self._members.append(converted)
+            elif self.get_cls(mem) == DoxyNamespace:
+                self._members += converted.members()
+                self._members.append(converted)
             else:
                 self._members.append(converted)
 
@@ -80,6 +85,22 @@
         self._data['brief_description'] = bd
         self._data['detailed_description'] = dd
 
+    def set_parameters(self, data):
+        vs = [ddc.value for ddc in data.detaileddescription.content_]
+        pls = []
+        for v in vs:
+            if hasattr(v, 'parameterlist'):
+                pls += v.parameterlist
+        pis = []
+        for pl in pls:
+            pis += pl.parameteritem
+        dpis = []
+        for pi in pis:
+            dpi = DoxyParameterItem(pi)
+            dpi._parse()
+            dpis.append(dpi)
+        self._data['params'] = dpis
+
 class DoxyCompound(DoxyCompMem):
     pass
 
@@ -98,10 +119,13 @@
             return
         super(DoxyFunction, self)._parse()
         self.set_descriptions(self._parse_data)
-        self._data['params'] = []
-        prms = self._parse_data.param
-        for prm in prms:
-            self._data['params'].append(DoxyParam(prm))
+        self.set_parameters(self._parse_data)
+        if not self._data['params']:
+            # If the params weren't set by a comment then just grab the names.
+            self._data['params'] = []
+            prms = self._parse_data.param
+            for prm in prms:
+                self._data['params'].append(DoxyParam(prm))
 
     brief_description = property(lambda self: self.data()['brief_description'])
     detailed_description = property(lambda self: self.data()['detailed_description'])
@@ -121,9 +145,38 @@
         self.set_descriptions(self._parse_data)
         self._data['declname'] = self._parse_data.declname
 
+    @property
+    def description(self):
+        descriptions = []
+        if self.brief_description:
+            descriptions.append(self.brief_description)
+        if self.detailed_description:
+            descriptions.append(self.detailed_description)
+        return '\n\n'.join(descriptions)
+
     brief_description = property(lambda self: self.data()['brief_description'])
     detailed_description = property(lambda self: self.data()['detailed_description'])
-    declname = property(lambda self: self.data()['declname'])
+    name = property(lambda self: self.data()['declname'])
+
+class DoxyParameterItem(DoxyMember):
+    """A different representation of a parameter in Doxygen."""
+
+    def _parse(self):
+        if self._parsed:
+            return
+        super(DoxyParameterItem, self)._parse()
+        names = []
+        for nl in self._parse_data.parameternamelist:
+            for pn in nl.parametername:
+                names.append(description(pn))
+        # Just take first name
+        self._data['name'] = names[0]
+        # Get description
+        pd = description(self._parse_data.get_parameterdescription())
+        self._data['description'] = pd
+
+    description = property(lambda self: self.data()['description'])
+    name = property(lambda self: self.data()['name'])
 
 class DoxyClass(DoxyCompound):
 
@@ -139,12 +192,14 @@
         if self._error:
             return
         self.set_descriptions(self._retrieved_data.compounddef)
+        self.set_parameters(self._retrieved_data.compounddef)
         # Sectiondef.kind tells about whether private or public.
         # We just ignore this for now.
         self.process_memberdefs()
 
     brief_description = property(lambda self: self.data()['brief_description'])
     detailed_description = property(lambda self: self.data()['detailed_description'])
+    params = property(lambda self: self.data()['params'])
 
 Base.mem_classes.append(DoxyClass)
 
@@ -177,6 +232,16 @@
 
     kind = 'namespace'
 
+    def _parse(self):
+        if self._parsed:
+            return
+        super(DoxyNamespace, self)._parse()
+        self.retrieve_data()
+        self.set_descriptions(self._retrieved_data.compounddef)
+        if self._error:
+            return
+        self.process_memberdefs()
+
 Base.mem_classes.append(DoxyNamespace)
 
 
@@ -227,7 +292,8 @@
 
     __module__ = "gnuradio.utils.doxyxml"
 
-    kinds = set(['variable', 'struct', 'union', 'define', 'typedef', 'enum', 'dir', 'page'])
+    kinds = set(['variable', 'struct', 'union', 'define', 'typedef', 'enum',
+                 'dir', 'page', 'signal', 'slot', 'property'])
 
     @classmethod
     def can_parse(cls, obj):
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/__init__.py gr-lora-0.6.2/docs/doxygen/doxyxml/generated/__init__.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/__init__.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/generated/__init__.py	2019-08-14 23:20:45.290000000 +0000
@@ -5,3 +5,4 @@
 resultant classes are not very friendly to navigate so the rest of the
 doxyxml module processes them further.
 """
+from __future__ import unicode_literals
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compound.py gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compound.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compound.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compound.py	2019-08-14 23:37:12.660000000 +0000
@@ -1,17 +1,18 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python3
 
 """
 Generated Mon Feb  9 19:08:05 2009 by generateDS.py.
 """
+from __future__ import absolute_import
+from __future__ import unicode_literals
 
-from string import lower as str_lower
 from xml.dom import minidom
 from xml.dom import Node
 
 import sys
 
-import compoundsuper as supermod
-from compoundsuper import MixedContainer
+from . import compoundsuper as supermod
+from .compoundsuper import MixedContainer
 
 
 class DoxygenTypeSub(supermod.DoxygenType):
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compoundsuper.py gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compoundsuper.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compoundsuper.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/generated/compoundsuper.py	2019-08-14 23:20:45.300000000 +0000
@@ -1,14 +1,16 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python3
 
 #
 # Generated Thu Jun 11 18:44:25 2009 by generateDS.py.
 #
 
+from __future__ import print_function
+from __future__ import unicode_literals
+
 import sys
-import getopt
-from string import lower as str_lower
 from xml.dom import minidom
 from xml.dom import Node
+import six
 
 #
 # User methods
@@ -19,9 +21,9 @@
 
 try:
     from generatedssuper import GeneratedsSuper
-except ImportError, exp:
+except ImportError as exp:
 
-    class GeneratedsSuper:
+    class GeneratedsSuper(object):
         def format_string(self, input_data, input_name=''):
             return input_data
         def format_integer(self, input_data, input_name=''):
@@ -64,7 +66,7 @@
         outfile.write('    ')
 
 def quote_xml(inStr):
-    s1 = (isinstance(inStr, basestring) and inStr or
+    s1 = (isinstance(inStr, six.string_types) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
@@ -72,7 +74,7 @@
     return s1
 
 def quote_attrib(inStr):
-    s1 = (isinstance(inStr, basestring) and inStr or
+    s1 = (isinstance(inStr, six.string_types) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
@@ -102,7 +104,7 @@
             return '"""%s"""' % s1
 
 
-class MixedContainer:
+class MixedContainer(object):
     # Constants for category:
     CategoryNone = 0
     CategoryText = 1
@@ -4221,7 +4223,7 @@
         if attrs.get('lineno'):
             try:
                 self.lineno = int(attrs.get('lineno').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (lineno): %s' % exp)
         if attrs.get('refkind'):
             self.refkind = attrs.get('refkind').value
@@ -4504,12 +4506,12 @@
         if attrs.get('endline'):
             try:
                 self.endline = int(attrs.get('endline').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (endline): %s' % exp)
         if attrs.get('startline'):
             try:
                 self.startline = int(attrs.get('startline').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (startline): %s' % exp)
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
@@ -4627,17 +4629,17 @@
         if attrs.get('bodystart'):
             try:
                 self.bodystart = int(attrs.get('bodystart').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (bodystart): %s' % exp)
         if attrs.get('line'):
             try:
                 self.line = int(attrs.get('line').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (line): %s' % exp)
         if attrs.get('bodyend'):
             try:
                 self.bodyend = int(attrs.get('bodyend').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (bodyend): %s' % exp)
         if attrs.get('bodyfile'):
             self.bodyfile = attrs.get('bodyfile').value
@@ -6778,12 +6780,12 @@
         if attrs.get('rows'):
             try:
                 self.rows = int(attrs.get('rows').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (rows): %s' % exp)
         if attrs.get('cols'):
             try:
                 self.cols = int(attrs.get('cols').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (cols): %s' % exp)
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
@@ -7108,7 +7110,7 @@
         if attrs.get('level'):
             try:
                 self.level = int(attrs.get('level').value)
-            except ValueError, exp:
+            except ValueError as exp:
                 raise ValueError('Bad integer attribute (level): %s' % exp)
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
@@ -8283,7 +8285,7 @@
 """
 
 def usage():
-    print USAGE_TEXT
+    print(USAGE_TEXT)
     sys.exit(1)
 
 
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/index.py gr-lora-0.6.2/docs/doxygen/doxyxml/generated/index.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/index.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/generated/index.py	2019-08-14 23:20:45.300000000 +0000
@@ -1,16 +1,18 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python3
 
 """
 Generated Mon Feb  9 19:08:05 2009 by generateDS.py.
 """
+from __future__ import absolute_import
+from __future__ import unicode_literals
 
 from xml.dom import minidom
 
 import os
 import sys
-import compound
+from . import compound
 
-import indexsuper as supermod
+from . import indexsuper as supermod
 
 class DoxygenTypeSub(supermod.DoxygenType):
     def __init__(self, version=None, compound=None):
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/indexsuper.py gr-lora-0.6.2/docs/doxygen/doxyxml/generated/indexsuper.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/generated/indexsuper.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/generated/indexsuper.py	2019-08-14 23:20:45.290000000 +0000
@@ -1,14 +1,15 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python3
 
 #
 # Generated Thu Jun 11 18:43:54 2009 by generateDS.py.
 #
+from __future__ import print_function
+from __future__ import unicode_literals
 
 import sys
-import getopt
-from string import lower as str_lower
 from xml.dom import minidom
 from xml.dom import Node
+import six
 
 #
 # User methods
@@ -19,9 +20,9 @@
 
 try:
     from generatedssuper import GeneratedsSuper
-except ImportError, exp:
+except ImportError as exp:
 
-    class GeneratedsSuper:
+    class GeneratedsSuper(object):
         def format_string(self, input_data, input_name=''):
             return input_data
         def format_integer(self, input_data, input_name=''):
@@ -64,7 +65,7 @@
         outfile.write('    ')
 
 def quote_xml(inStr):
-    s1 = (isinstance(inStr, basestring) and inStr or
+    s1 = (isinstance(inStr, six.string_types) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
@@ -72,7 +73,7 @@
     return s1
 
 def quote_attrib(inStr):
-    s1 = (isinstance(inStr, basestring) and inStr or
+    s1 = (isinstance(inStr, six.string_types) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
@@ -102,7 +103,7 @@
             return '"""%s"""' % s1
 
 
-class MixedContainer:
+class MixedContainer(object):
     # Constants for category:
     CategoryNone = 0
     CategoryText = 1
@@ -462,7 +463,7 @@
 """
 
 def usage():
-    print USAGE_TEXT
+    print(USAGE_TEXT)
     sys.exit(1)
 
 
diff -Nur src/gr-lora-0.6.2/docs/doxygen/doxyxml/text.py gr-lora-0.6.2/docs/doxygen/doxyxml/text.py
--- src/gr-lora-0.6.2/docs/doxygen/doxyxml/text.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/doxyxml/text.py	2019-08-14 23:20:45.290000000 +0000
@@ -21,12 +21,13 @@
 """
 Utilities for extracting text from generated classes.
 """
+from __future__ import unicode_literals
 
 def is_string(txt):
     if isinstance(txt, str):
         return True
     try:
-        if isinstance(txt, unicode):
+        if isinstance(txt, str):
             return True
     except NameError:
         pass
@@ -49,7 +50,7 @@
     elif is_string(obj):
         return obj
     else:
-        raise StandardError('Expecting a string or something with content, content_ or value attribute')
+        raise Exception('Expecting a string or something with content, content_ or value attribute')
     # If this bit is a paragraph then add one some line breaks.
     if hasattr(obj, 'name') and obj.name == 'para':
         result += "\n\n"
diff -Nur src/gr-lora-0.6.2/docs/doxygen/swig_doc.py gr-lora-0.6.2/docs/doxygen/swig_doc.py
--- src/gr-lora-0.6.2/docs/doxygen/swig_doc.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/docs/doxygen/swig_doc.py	2019-08-14 23:23:53.330000000 +0000
@@ -27,13 +27,12 @@
 
 """
 
-import sys
+from __future__ import unicode_literals
 
-try:
-    from doxyxml import DoxyIndex, DoxyClass, DoxyFriend, DoxyFunction, DoxyFile, base
-except ImportError:
-    from gnuradio.doxyxml import DoxyIndex, DoxyClass, DoxyFriend, DoxyFunction, DoxyFile, base
+import sys, time
 
+from doxyxml import DoxyIndex, DoxyClass, DoxyFriend, DoxyFunction, DoxyFile
+from doxyxml import DoxyOther, base
 
 def py_name(name):
     bits = name.split('_')
@@ -56,8 +55,28 @@
         # Check for a parsing error.
         if item.error():
             return False
-        return item.has_member(make_name(item.name()), DoxyFriend)
+        friendname = make_name(item.name())
+        is_a_block = item.has_member(friendname, DoxyFriend)
+        # But now sometimes the make function isn't a friend so check again.
+        if not is_a_block:
+            is_a_block = di.has_member(friendname, DoxyFunction)
+        return is_a_block
 
+class Block2(object):
+    """
+    Checks if doxyxml produced objects correspond to a new style
+    gnuradio block.
+    """
+
+    @classmethod
+    def includes(cls, item):
+        if not isinstance(item, DoxyClass):
+            return False
+        # Check for a parsing error.
+        if item.error():
+            return False
+        is_a_block2 = item.has_member('make', DoxyFunction) and item.has_member('sptr', DoxyOther)
+        return is_a_block2
 
 def utoascii(text):
     """
@@ -66,9 +85,10 @@
     if text is None:
         return ''
     out = text.encode('ascii', 'replace')
-    out = out.replace('"', '\\"')
-    return out
-
+    # swig will require us to replace blackslash with 4 backslashes
+    out = out.replace(b'\\', b'\\\\\\\\')
+    out = out.replace(b'"', b'\\"').decode('ascii')
+    return str(out)
 
 def combine_descriptions(obj):
     """
@@ -83,9 +103,15 @@
         description.append(dd)
     return utoascii('\n\n'.join(description)).strip()
 
+def format_params(parameteritems):
+    output = ['Args:']
+    template = '    {0} : {1}'
+    for pi in parameteritems:
+        output.append(template.format(pi.name, pi.description))
+    return '\n'.join(output)
 
 entry_templ = '%feature("docstring") {name} "{docstring}"'
-def make_entry(obj, name=None, templ="{description}", description=None):
+def make_entry(obj, name=None, templ="{description}", description=None, params=[]):
     """
     Create a docstring entry for a swig interface file.
 
@@ -102,6 +128,9 @@
         return ''
     if description is None:
         description = combine_descriptions(obj)
+    if params:
+        description += '\n\n'
+        description += utoascii(format_params(params))
     docstring = templ.format(description=description)
     if not docstring:
         return ''
@@ -121,27 +150,31 @@
             used as the description instead of extracting it from func.
     params - a parameter list that overrides using func.params.
     """
-    if params is None:
-        params = func.params
-    params = [prm.declname for prm in params]
-    if params:
-        sig = "Params: (%s)" % ", ".join(params)
-    else:
-        sig = "Params: (NONE)"
-    templ = "{description}\n\n" + sig
-    return make_entry(func, name=name, templ=utoascii(templ),
-                      description=description)
+    #if params is None:
+    #    params = func.params
+    #params = [prm.declname for prm in params]
+    #if params:
+    #    sig = "Params: (%s)" % ", ".join(params)
+    #else:
+    #    sig = "Params: (NONE)"
+    #templ = "{description}\n\n" + sig
+    #return make_entry(func, name=name, templ=utoascii(templ),
+    #                  description=description)
+    return make_entry(func, name=name, description=description, params=params)
 
 
-def make_class_entry(klass, description=None):
+def make_class_entry(klass, description=None, ignored_methods=[], params=None):
     """
     Create a class docstring for a swig interface file.
     """
+    if params is None:
+        params = klass.params
     output = []
-    output.append(make_entry(klass, description=description))
+    output.append(make_entry(klass, description=description, params=params))
     for func in klass.in_category(DoxyFunction):
-        name = klass.name() + '::' + func.name()
-        output.append(make_func_entry(func, name=name))
+        if func.name() not in ignored_methods:
+            name = klass.name() + '::' + func.name()
+            output.append(make_func_entry(func, name=name))
     return "\n\n".join(output)
 
 
@@ -175,11 +208,33 @@
     # the make function.
     output = []
     output.append(make_class_entry(block, description=super_description))
-    creator = block.get_member(block.name(), DoxyFunction)
     output.append(make_func_entry(make_func, description=super_description,
-                                  params=creator.params))
+                                  params=block.params))
     return "\n\n".join(output)
 
+def make_block2_entry(di, block):
+    """
+    Create class and function docstrings of a new style gnuradio block for a
+    swig interface file.
+    """
+    descriptions = []
+    # For new style blocks all the relevant documentation should be
+    # associated with the 'make' method.
+    class_description = combine_descriptions(block)
+    make_func = block.get_member('make', DoxyFunction)
+    make_description = combine_descriptions(make_func)
+    description = class_description + "\n\nConstructor Specific Documentation:\n\n" + make_description
+    # Associate the combined description with the class and
+    # the make function.
+    output = []
+    output.append(make_class_entry(
+            block, description=description,
+            ignored_methods=['make'], params=make_func.params))
+    makename = block.name() + '::make'
+    output.append(make_func_entry(
+            make_func, name=makename, description=description,
+            params=make_func.params))
+    return "\n\n".join(output)
 
 def make_swig_interface_file(di, swigdocfilename, custom_output=None):
 
@@ -196,39 +251,59 @@
 
     # Create docstrings for the blocks.
     blocks = di.in_category(Block)
+    blocks2 = di.in_category(Block2)
+
     make_funcs = set([])
     for block in blocks:
         try:
             make_func = di.get_member(make_name(block.name()), DoxyFunction)
-            make_funcs.add(make_func.name())
-            output.append(make_block_entry(di, block))
+            # Don't want to risk writing to output twice.
+            if make_func.name() not in make_funcs:
+                make_funcs.add(make_func.name())
+                output.append(make_block_entry(di, block))
+        except block.ParsingError:
+            sys.stderr.write('Parsing error for block {0}\n'.format(block.name()))
+            raise
+
+    for block in blocks2:
+        try:
+            make_func = block.get_member('make', DoxyFunction)
+            make_func_name = block.name() +'::make'
+            # Don't want to risk writing to output twice.
+            if make_func_name not in make_funcs:
+                make_funcs.add(make_func_name)
+                output.append(make_block2_entry(di, block))
         except block.ParsingError:
-            print('Parsing error for block %s' % block.name())
+            sys.stderr.write('Parsing error for block {0}\n'.format(block.name()))
+            raise
 
     # Create docstrings for functions
     # Don't include the make functions since they have already been dealt with.
-    funcs = [f for f in di.in_category(DoxyFunction) if f.name() not in make_funcs]
+    funcs = [f for f in di.in_category(DoxyFunction)
+             if f.name() not in make_funcs and not f.name().startswith('std::')]
     for f in funcs:
         try:
             output.append(make_func_entry(f))
         except f.ParsingError:
-            print('Parsing error for function %s' % f.name())
+            sys.stderr.write('Parsing error for function {0}\n'.format(f.name()))
 
     # Create docstrings for classes
     block_names = [block.name() for block in blocks]
-    klasses = [k for k in di.in_category(DoxyClass) if k.name() not in block_names]
+    block_names += [block.name() for block in blocks2]
+    klasses = [k for k in di.in_category(DoxyClass)
+               if k.name() not in block_names and not k.name().startswith('std::')]
     for k in klasses:
         try:
             output.append(make_class_entry(k))
         except k.ParsingError:
-            print('Parsing error for class %s' % k.name())
+            sys.stderr.write('Parsing error for class {0}\n'.format(k.name()))
 
     # Docstrings are not created for anything that is not a function or a class.
     # If this excludes anything important please add it here.
 
     output = "\n\n".join(output)
 
-    swig_doc = file(swigdocfilename, 'w')
+    swig_doc = open(swigdocfilename, 'w')
     swig_doc.write(output)
     swig_doc.close()
 
@@ -236,7 +311,7 @@
     # Parse command line options and set up doxyxml.
     err_msg = "Execute using: python swig_doc.py xml_path outputfilename"
     if len(sys.argv) != 3:
-        raise StandardError(err_msg)
+        raise Exception(err_msg)
     xml_path = sys.argv[1]
     swigdocfilename = sys.argv[2]
     di = DoxyIndex(xml_path)
diff -Nur src/gr-lora-0.6.2/lib/CMakeLists.txt gr-lora-0.6.2/lib/CMakeLists.txt
--- src/gr-lora-0.6.2/lib/CMakeLists.txt	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/lib/CMakeLists.txt	2019-08-15 01:14:47.300000000 +0000
@@ -22,9 +22,6 @@
 ########################################################################
 include(GrPlatform) #define LIB_SUFFIX
 
-include_directories(${Boost_INCLUDE_DIR})
-link_directories(${Boost_LIBRARY_DIRS})
-
 list(APPEND lora_sources
     decoder_impl.cc
     message_file_sink_impl.cc
@@ -41,8 +38,13 @@
 endif(NOT lora_sources)
 
 add_library(gnuradio-lora SHARED ${lora_sources})
-target_link_libraries(gnuradio-lora ${Boost_LIBRARIES} ${GNURADIO_ALL_LIBRARIES} liquid)
+target_link_libraries(gnuradio-lora ${Boost_LIBRARIES} ${GNURADIO_ALL_LIBRARIES} liquid log4cpp)
 set_target_properties(gnuradio-lora PROPERTIES DEFINE_SYMBOL "gnuradio_lora_EXPORTS")
+target_include_directories(gnuradio-lora
+    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/../include>
+    PUBLIC $<BUILD_INTERFACE:${Boost_INCLUDE_DIR}>
+    PUBLIC $<INSTALL_INTERFACE:include>
+  )
 
 if(APPLE)
     set_target_properties(gnuradio-lora PROPERTIES
diff -Nur src/gr-lora-0.6.2/lib/channelizer_impl.cc gr-lora-0.6.2/lib/channelizer_impl.cc
--- src/gr-lora-0.6.2/lib/channelizer_impl.cc	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/lib/channelizer_impl.cc	2019-08-15 01:06:07.470000000 +0000
@@ -47,7 +47,7 @@
         d_freq_offset = channel_list[0] - center_freq;
         d_xlating_fir_filter = gr::filter::freq_xlating_fir_filter_ccf::make(1, d_lpf, d_freq_offset, out_samp_rate);
         d_controller = gr::lora::controller::make((void*)this);
-        d_resampler = gr::filter::fractional_resampler_cc::make(0, (float)in_samp_rate / (float)out_samp_rate);
+        d_resampler = gr::filter::mmse_resampler_cc::make(0, (float)in_samp_rate / (float)out_samp_rate);
         //self.delay             = delay(gr.sizeof_gr_complex, int((len(lpf)-1) / 2.0))
 
         //Create message ports
diff -Nur src/gr-lora-0.6.2/lib/channelizer_impl.h gr-lora-0.6.2/lib/channelizer_impl.h
--- src/gr-lora-0.6.2/lib/channelizer_impl.h	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/lib/channelizer_impl.h	2019-08-15 01:04:41.060000000 +0000
@@ -24,8 +24,8 @@
 
 #include <lora/channelizer.h>
 #include <lora/controller.h>
-#include <gnuradio/filter/freq_xlating_fir_filter_ccf.h>
-#include <gnuradio/filter/fractional_resampler_cc.h>
+#include <gnuradio/filter/freq_xlating_fir_filter.h>
+#include <gnuradio/filter/mmse_resampler_cc.h>
 #include <gnuradio/filter/firdes.h>
 
 namespace gr {
@@ -33,7 +33,7 @@
     class channelizer_impl : public channelizer {
      private:
          gr::filter::freq_xlating_fir_filter_ccf::sptr d_xlating_fir_filter;
-         gr::filter::fractional_resampler_cc::sptr d_resampler;
+         gr::filter::mmse_resampler_cc::sptr d_resampler;
          std::vector<float> d_lpf;
          float d_cfo;
          uint32_t d_freq_offset;
diff -Nur src/gr-lora-0.6.2/python/CMakeLists.txt gr-lora-0.6.2/python/CMakeLists.txt
--- src/gr-lora-0.6.2/python/CMakeLists.txt	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/python/CMakeLists.txt	2019-08-14 23:20:45.290000000 +0000
@@ -32,13 +32,15 @@
     FILES
     __init__.py
     lora_receiver.py
-    loraconfig.py DESTINATION ${GR_PYTHON_DIR}/lora
+    loraconfig.py
+    DESTINATION ${GR_PYTHON_DIR}/lora
 )
 
 if(HAS_MONGODB)
     GR_PYTHON_INSTALL(
         FILES
-        message_mongodb_sink.py DESTINATION ${GR_PYTHON_DIR}/lora
+        message_mongodb_sink.py
+        DESTINATION ${GR_PYTHON_DIR}/lora
     )
 endif(HAS_MONGODB)
 
diff -Nur src/gr-lora-0.6.2/python/build_utils.py gr-lora-0.6.2/python/build_utils.py
--- src/gr-lora-0.6.2/python/build_utils.py	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/python/build_utils.py	2019-08-14 23:20:45.290000000 +0000
@@ -29,7 +29,7 @@
 # set srcdir to the directory that contains Makefile.am
 try:
     srcdir = os.environ['srcdir']
-except KeyError, e:
+except KeyError as e:
     srcdir = "."
 srcdir = srcdir + '/'
 
@@ -39,7 +39,7 @@
         do_makefile = False
     else:
         do_makefile = True
-except KeyError, e:
+except KeyError as e:
     do_makefile = False
 
 # set do_sources to either true or false dependeing on the environment
@@ -48,7 +48,7 @@
         do_sources = False
     else:
         do_sources = True
-except KeyError, e:
+except KeyError as e:
     do_sources = True
 
 name_dict = {}
diff -Nur src/gr-lora-0.6.2/swig/CMakeLists.txt gr-lora-0.6.2/swig/CMakeLists.txt
--- src/gr-lora-0.6.2/swig/CMakeLists.txt	2017-09-15 11:45:40.000000000 +0000
+++ gr-lora-0.6.2/swig/CMakeLists.txt	2019-08-15 01:09:32.190000000 +0000
@@ -29,7 +29,7 @@
 # Include swig generation macros
 ########################################################################
 find_package(SWIG)
-find_package(PythonLibs 2)
+find_package(PythonLibs)
 if(NOT SWIG_FOUND OR NOT PYTHONLIBS_FOUND)
     return()
 endif()
@@ -39,9 +39,9 @@
 ########################################################################
 # Setup swig generation
 ########################################################################
-foreach(incdir ${GNURADIO_RUNTIME_INCLUDE_DIRS})
-    list(APPEND GR_SWIG_INCLUDE_DIRS ${incdir}/gnuradio/swig)
-endforeach(incdir)
+set(GR_SWIG_INCLUDE_DIRS
+   $<TARGET_PROPERTY:gnuradio::runtime_swig,INTERFACE_INCLUDE_DIRECTORIES>)
+set(GR_SWIG_TARGET_DEPS gnuradio::runtime_swig)
 
 set(GR_SWIG_LIBRARIES gnuradio-lora)
 set(GR_SWIG_DOC_FILE ${CMAKE_CURRENT_BINARY_DIR}/lora_swig_doc.i)
