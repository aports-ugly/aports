--- a/extensions/ip_cloaking_4.0.c	2015-01-25 21:11:16.000000000 +0000
+++ b/extensions/ip_cloaking_4.0.c	2015-02-14 18:14:00.433382899 +0000
@@ -72,95 +72,6 @@
 }
 
 static void
-do_host_cloak_ip(const char *inbuf, char *outbuf)
-{
-	/* None of the characters in this table can be valid in an IP */
-	char chartable[] = "ghijklmnopqrstuvwxyz";
-	char *tptr;
-	uint32_t accum = fnv_hash((const unsigned char*) inbuf, 32);
-	int sepcount = 0;
-	int totalcount = 0;
-	int ipv6 = 0;
-
-	rb_strlcpy(outbuf, inbuf, HOSTLEN + 1);
-
-	if (strchr(outbuf, ':'))
-	{
-		ipv6 = 1;
-
-		/* Damn you IPv6...
-		 * We count the number of colons so we can calculate how much
-		 * of the host to cloak. This is because some hostmasks may not
-		 * have as many octets as we'd like.
-		 *
-		 * We have to do this ahead of time because doing this during
-		 * the actual cloaking would get ugly
-		 */
-		for (tptr = outbuf; *tptr != '\0'; tptr++)
-			if (*tptr == ':')
-				totalcount++;
-	}
-	else if (!strchr(outbuf, '.'))
-		return;
-
-	for (tptr = outbuf; *tptr != '\0'; tptr++)
-	{
-		if (*tptr == ':' || *tptr == '.')
-		{
-			sepcount++;
-			continue;
-		}
-
-		if (ipv6 && sepcount < totalcount / 2)
-			continue;
-
-		if (!ipv6 && sepcount < 2)
-			continue;
-
-		*tptr = chartable[(*tptr + accum) % 20];
-		accum = (accum << 1) | (accum >> 31);
-	}
-}
-
-static void
-do_host_cloak_host(const char *inbuf, char *outbuf)
-{
-	char b26_alphabet[] = "abcdefghijklmnopqrstuvwxyz";
-	char *tptr;
-	uint32_t accum = fnv_hash((const unsigned char*) inbuf, 32);
-
-	rb_strlcpy(outbuf, inbuf, HOSTLEN + 1);
-
-	/* pass 1: scramble first section of hostname using base26
-	 * alphabet toasted against the FNV hash of the string.
-	 *
-	 * numbers are not changed at this time, only letters.
-	 */
-	for (tptr = outbuf; *tptr != '\0'; tptr++)
-	{
-		if (*tptr == '.')
-			break;
-
-		if (isdigit(*tptr) || *tptr == '-')
-			continue;
-
-		*tptr = b26_alphabet[(*tptr + accum) % 26];
-
-		/* Rotate one bit to avoid all digits being turned odd or even */
-		accum = (accum << 1) | (accum >> 31);
-	}
-
-	/* pass 2: scramble each number in the address */
-	for (tptr = outbuf; *tptr != '\0'; tptr++)
-	{
-		if (isdigit(*tptr))
-			*tptr = '0' + (*tptr + accum) % 10;
-
-		accum = (accum << 1) | (accum >> 31);
-	}
-}
-
-static void
 check_umode_change(void *vdata)
 {
 	hook_data_umode_changed *data = (hook_data_umode_changed *)vdata;
@@ -208,11 +119,11 @@
 		source_p->umodes &= ~user_modes['x'];
 		return;
 	}
-	source_p->localClient->mangledhost = rb_malloc(HOSTLEN + 1);
-	if (!irccmp(source_p->orighost, source_p->sockhost))
-		do_host_cloak_ip(source_p->orighost, source_p->localClient->mangledhost);
-	else
-		do_host_cloak_host(source_p->orighost, source_p->localClient->mangledhost);
+	//source_p->localClient->mangledhost = rb_malloc(strlen(source_p->name)+21);
+	source_p->localClient->mangledhost = rb_malloc(20);
+	//rb_strlcpy(source_p->localClient->mangledhost, source_p->name , strlen(source_p->name)+21);
+	//rb_strlcat(source_p->localClient->mangledhost, ".users.darkfasel.net", strlen(source_p->name)+21);
+	rb_strlcpy(source_p->localClient->mangledhost, "users.darkfasel.net", 20);
 	if (IsDynSpoof(source_p))
 		source_p->umodes &= ~user_modes['x'];
 	if (source_p->umodes & user_modes['x'])
